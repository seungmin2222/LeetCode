## [Final Prices With a Special Discount in a Shop](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/)

이 문제는 배열 `prices`를 입력받아 각 항목의 최종 가격을 계산한 결과를 반환하는 것이다.

## 주요 포인트

1. **중첩 반복문(Nested Loops)**
    - 문제에서는 현재 요소와 이후 요소를 비교하기 위해 이중 반복문을 사용한다.
    - O(n^2) 복잡도를 가지므로, 효율성 문제를 고민해야 할 때가 있다.
2. **조건 기반 탐색**
    - 특정 조건을 만족하는 값을 찾는 로직을 구현해야 한다.
    - 예를 들어, `prices[j] <= prices[i]` 조건을 만족하는 첫 번째 값을 찾는 것이 이 문제의 핵심이다.
3. **시간 복잡도와 공간 복잡도**
    - 반복문이 많아지면 알고리즘의 시간 복잡도가 증가한다. 여기서는 이중 반복문으로 O(n^2)를 가진다.
        
        O(n^2)
        
    - 공간 복잡도는 결과 배열이나 임시 변수를 고려하여 계산해야 한다.

## 나의 코드

```jsx
var finalPrices = function(prices) {
  const result = [];

  for (let i = 0; i < prices.length; i++) {
    let discount = 0;

    for (let j = i + 1; j < prices.length; j++) {
      if (prices[j] <= prices[i]) {
        discount = prices[j];
        break;
      }
    }

    result.push(prices[i] - discount);
  }

  return result;
};
```

## 나의 수도 코드

1. 각 항목의 가격을 순회.
2. 현재 항목 이후의 항목을 순회하며 첫 번째로 조건을 만족하는 할인을 찾음.
3. `prices[j] <= prices[i]`를 만족하는 첫 번째 `j`를 찾음.
4. 결과를 `result` 배열에 저장한 뒤 최종적으로 반환.

## 시간 복잡도

최악의 경우, 모든 요소 쌍을 비교해야 하므로 시간 복잡도는 이중 루프에 의해 O(n^2).

## 공간 복잡도

- **입력 배열 `prices`**: O(n) → 이미 입력으로 주어진 배열이므로 추가 공간에 포함하지 않는다.
- **결과 배열 `result`**: O(n)
- **상수 공간 (임시 변수 및 루프 변수)**: O(1)

따라서, 이 코드의 **총 공간 복잡도는** : O(n)

## 회고

이번 문제는 **특정 조건을 만족하는 할인 계산**을 통해 배열을 처리하는 문제로, 기본적인 **이중 반복문**을 활용하여 해결했다. 시간 복잡도는 O(n^2)로 비효율적일 수 있지만, 문제의 크기가 작을 경우 충분히 작동 가능한 풀이이다.

공간 복잡도는 O(n)로, 입력 배열과 동일한 크기의 결과 배열을 생성하므로 추가 공간 사용은 최소화되었다.

이번 풀이를 통해 **조건 기반 탐색과 배열 조작의 기본 원리**를 복습할 수 있었다.

차후에는 스택을 활용해 시간 복잡도를 O(n)로 개선하는 방법도 고민해볼 만하다.
