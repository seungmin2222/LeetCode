## [Word Break](https://leetcode.com/problems/word-break)

이 문제는 주어진 문자열 `s`를 단어 사전 `wordDict`에 있는 단어들로 분할할 수 있는지 판단하는 문제다.

단어는 여러번 사용 할 수 있다.

## 주요 포인트

1. **동적 계획법(Dynamic Programming) 활용**
    - 문자열의 각 위치까지 분할 가능한지를 저장하는 DP 배열을 사용한다.
2. **단어 사전 최적화**
    - 단어 조회를 빠르게 하기 위해 `Set` 자료구조로 변환한다.
3. **부분 문자열 검사**
    - 각 인덱스에서 이전 인덱스까지의 부분 문자열이 사전에 있는지 확인한다.
4. **기본 사례 설정**
    - 빈 문자열은 항상 분할 가능하다고 간주하여 `dp[0]`을 `true`로 설정한다.
5. **효율성 고려**
    - 중복 계산을 피하고 시간 복잡도를 최소화하기 위해 최적화된 루프 구조를 설계한다.

## 나의 코드

```jsx
var wordBreak = function(s, wordDict) {
  const wordSet = new Set(wordDict);
  const dp = new Array(s.length + 1).fill(false);

  dp[0] = true;

  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < i; j++) {
      if (dp[j] && wordSet.has(s.substring(j, i))) {
        dp[i] = true;
        break;
      }
    }
  }

  return dp[s.length];
};
```

## 나의 수도 코드

1. `wordSet`을 생성하여 `wordDict`의 단어들을 집합으로 저장한다.
2. 문자열 `s`의 길이보다 하나 더 큰 크기의 배열 `dp`를 모두 `false`로 초기화한다.
3. `dp[0]`을 `true`로 설정한다. (빈 문자열은 항상 분할 가능)
4. `i`를 1부터 `s.length`까지 반복한다.
5. `j`를 0부터 `i`까지 반복한다.
    - 만약 `dp[j]`가 `true`이고, `s[j:i]`가 `wordSet`에 존재하면`dp[i]`를 `true`로 설정한다.
    - 내부 루프를 종료한다. (더 이상의 검사 불필요)
6. `dp[s.length]`의 값을 반환한다. (문자열 전체가 분할 가능한지 여부)

## 알아둬야 할 것!

1. **동적 계획법 (Dynamic Programming)**
    - 큰 문제를 작은 부분 문제로 나누어 해결하고, 그 결과를 저장하여 중복 계산을 피하는 기법이다.
    - 이 문제에서는 문자열의 각 인덱스까지 분할 가능한지를 저장하는 `dp` 배열을 활용한다.
2. **문자열 조작**
    - 문자열의 부분 문자열을 추출하고 비교하는 능력이 필요하다.
    - `substring` 또는 슬라이싱을 통해 특정 구간의 문자열을 추출하는 방법을 이해해야 한다.
3. **집합 자료구조 (Set)**
    - 단어 사전의 단어들을 빠르게 조회하기 위해 `Set` 자료구조를 사용한다.
    - 해시 기반의 집합은 평균적으로 상수 시간 내에 원소의 존재 여부를 확인할 수 있다.
4. **이중 반복문**
    - 외부 루프와 내부 루프를 사용하여 모든 가능한 부분 문자열을 검사하는 방법을 이해해야 한다.
    - 이 문제에서는 두 개의 인덱스를 사용하여 모든 가능한 분할 지점을 탐색한다.

## 회고

이번 **Word Break** 문제를 풀면서 동적 계획법의 중요성을 다시 한 번 깨달았다.

특히, 문자열 분할과 같은 문제에서 부분 문제를 효율적으로 해결하고 결과를 저장하는 것이 얼마나 효과적인지를 체감할 수 있었다.

집합 자료구조를 활용하여 단어 사전의 단어들을 빠르게 조회하는 것이 전체 알고리즘의 효율성을 크게 향상시킨다는 것을 배웠다. 이처럼 자료구조의 선택이 알고리즘의 성능에 미치는 영향을 알 수 있었다.

이번 문제를 통해 동적 계획법과 효율적인 자료구조 사용의 중요성을 다시 한 번 확인할 수 있었으며, 이를 바탕으로 더 복잡한 문제들이 나왔을 때 적용시켜 봐야겠다.
