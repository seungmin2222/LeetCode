## [**Merge Intervals**](https://leetcode.com/problems/merge-intervals)

이 문제는 주어진 구간 배열에서 겹치는 구간들을 병합하여, 겹치지 않는 구간들만을 반환하는 문제이다.

## 주요 포인트

- **구간의 정렬**: 구간을 시작점을 기준으로 정렬해야 겹치는 구간을 쉽게 병합할 수 있다.
- **구간 겹침 여부 확인**: 두 구간이 겹치는지 확인하려면, 현재 구간의 끝점과 다음 구간의 시작점을 비교해야 한다.
- **구간 병합**: 겹치는 구간들은 하나의 구간으로 병합되는데, 병합된 구간의 끝점은 두 구간 중 더 큰 끝점을 가진다.
- **리스트 관리**: 병합된 구간들을 담을 리스트를 준비하여, 겹치지 않는 구간들은 그대로 추가하고, 겹치는 구간은 병합한 후 추가한다.
- **경계 값 처리**: 구간이 정확히 맞닿는 경우([1,4]와 [4,5]처럼), 이는 겹치는 것으로 간주되므로 병합이 필요하다

## 나의 코드

```jsx
var merge = function(intervals) {
  intervals.sort((a, b) => a[0] - b[0]);
  
  const arr = [];
    for (let i = 0; i < intervals.length; i++) {
      if (arr.length === 0 || arr[arr.length - 1][1] < intervals[i][0]) {
        arr.push(intervals[i]);
      } else {
        arr[arr.length - 1][1] = Math.max(arr[arr.length - 1][1], intervals[i][1]);
      }
    }
  return arr;
};
```

## 나의 수도 코드

1. **구간 정렬**
    - 입력된 `intervals` 배열을 시작값을 기준으로 오름차순 정렬
    - `sort` 함수를 이용하여 각 구간의 시작값(`a[0]`)을 비교하고, 오름차순으로 배치
2. **결과 배열 준비**
    - 빈 배열 `arr`을 준비하여, 병합된 구간들을 저장할 준비
3. **구간 순회**
    - `intervals` 배열의 각 구간을 순회
    - 만약 `arr`이 비어 있거나, 현재 구간이 이전에 병합된 구간과 겹치지 않으면 `arr`에 해당 구간을 추가
4. **구간 병합**
    - 만약 현재 구간이 이전 구간과 겹치면, 마지막으로 추가된 구간의 끝값을 현재 구간의 끝값 중 더 큰 값으로 업데이트하여 병합
5. **결과 반환**
    - 모든 구간을 순회한 후 병합된 구간이 저장된 `arr` 배열을 반환

## 알아둬야 할 것!

1. 그리디 알고리즘(Greedy Algorithm)
    - 이 문제는 그리디 알고리즘의 대표적인 예다.
    그리디 알고리즘은 매 단계에서 최적의 선택을 해서 문제를 풀어가는 방식이다.
    - 매 순간 겹치는 구간을 병합하거나, 겹치지 않으면 그대로 추가하는 방식이 최적의 해결책을 만들어낸다.
    - 공부 포인트: 그리디 알고리즘의 특징과 다른 그리디 문제들 (예: 회의실 배정 문제).
2. 구간 병합(Interval Merging)
    - 겹치는 구간을 병합하는 방법을 이해하는 것이 중요하다.
    - 두 구간이 겹치는지 확인하려면 현재 구간의 시작점이 이전 구간의 끝점보다 작거나 같은지를 비교한다.
    - 겹칠 경우, 병합된 구간의 끝점은 두 구간 끝점 중 더 큰 값이 된다.
    - 공부 포인트 : 구간 문제에서 자주 사용되는 방식으로, 예를 들어 스케줄링 문제, 작업 시간 조정 등이 있다.
3. 배열과 리스트 관리(Array and List Management)
    - 배열을 다루면서 병합된 결과를 저장할 때, 배열이나 리스트의 마지막 요소를 접근하여 데이터를 갱신하거나 새로운 데이터를 추가하는 것이 자주 사용된다. 이러한 배열 처리 방식은 문제 해결에서 중요한 부분이다.
    - 공부 포인트: 배열의 효율적인 사용법과 데이터 삽입 및 갱신에 대한 이해.

### 추가로 살펴볼 개념들

- 투 포인터(Two Pointers) 기법: 구간 문제에서 투 포인터 기법을 사용하는 경우가 종종 있는데, 이 문제의 경우 두 포인터 없이도 해결 가능하지만, 다른 구간 문제에서 투 포인터가 자주 사용된다.
- 경계값 분석: 두 구간이 정확히 맞닿는 경우(예: [1,4]와 [4,5]) 겹치는 것으로 간주하고 병합하는 규칙을 설정하는 것이 중요하다.

## 회고

이번에 풀었던 문제는 "구간 병합(Interval Merging)"이라는 주제를 다루는 문제였다. 주어진 구간들을 겹치는 부분 없이 병합하고, 새로운 구간 리스트를 반환하는 것이 목표였다. 문제 자체는 간단하게 느껴졌지만, 막상 코드를 작성하다 보니 생각해야 할 부분이 많았다. 특히 구간을 어떻게 정렬하고, 겹치는 부분을 어떻게 판단할 것인지가 핵심이었다.

처음 코드를 작성할 때, 무작정 배열을 순회하면서 병합을 시도했다. 하지만 구간이 정렬되지 않은 상태에서는 구간이 겹치는지 쉽게 확인할 수 없다는 점을 금방 깨달았다. 결국, 구간을 시작점을 기준으로 정렬하고 나니 병합 과정이 한층 쉬워졌다.

처음에 정렬 없이 문제를 풀려고 시도한 부분이 아쉬웠다. 정렬이 핵심이었음에도 불구하고, 바로 생각하지 못하고 헤맸던 것이 조금 아쉬웠다. 앞으로는 문제의 조건을 보고, 정렬이 필요한 경우를 더 빨리 캐치할 수 있도록 해야겠다.
