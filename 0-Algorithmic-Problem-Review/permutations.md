## [**Permutations**](https://leetcode.com/problems/permutations/)

이 문제는 주어진 배열 `nums`의 모든 가능한 순열(permutations)을 구하는 문제다.

각 숫자가 배열 내에서 고유하고, 배열에 있는 숫자들의 순서를 바꿔 가능한 모든 배열을 생성하는 것을 목표로 한다.

## 주요 포인트

1. **순열의 개념**
    - 주어진 요소들(숫자)의 순서를 바꿔서 나올 수 있는 모든 경우의 수를 의미한다.
    - 즉, 순열의 개념을 이해하고 있어야 한다.
2. **백트래킹 알고리즘**
    - 순열 문제는 백트래킹(Backtracking)을 통해 해결할 수 있다.
    - 백트래킹은 각 경로에서 가능한 선택을 탐색하고, 잘못된 선택을 되돌리는(undo) 방법이다.
3. **스왑(swap) 동작**
    - 배열의 두 값을 교환하는 방식으로 순열을 생성할 수 있다.
    - 스왑을 통해 새로운 순서를 만들고, 탐색이 끝나면 원래 상태로 복구한다.
4. **재귀 호출**
    - 깊이 우선 탐색(DFS)을 통해 각 숫자를 차례로 선택해 나가면서 새로운 순열을 만들어 나가는 과정이 반복된다.

## 나의 코드

```tsx
var permute = function(nums) {
  const result = [];

  const dfs = (i, arr) => {
    if (i === arr.length) {
      return result.push([...arr]);
    }

    for (let j = i; j < arr.length; j++) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      dfs(i + 1, arr);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  };
   
  dfs(0, nums);

  return result;
};
```

## 나의 수도 코드

1. 함수 permute(nums)를 정의
    - 입력: 숫자 배열 nums
    - 출력: 모든 가능한 순열을 포함하는 배열 result
2. result 배열을 빈 배열로 초기화
    - 배열은 가능한 모든 순열을 저장할 것
3. 깊이 우선 탐색(DFS) 함수 dfs(i, arr)를 정의
    - 현재 인덱스 i와 배열 arr
4. 만약 i가 arr 배열의 길이와 같다면,
    - 현재 배열 arr은 하나의 완전한 순열
    - arr 배열의 복사본을 result 배열에 추가
5. i부터 arr의 끝까지 반복문을 실행
    - 반복문 변수 j는 i부터 시작
6. 반복문 내에서 다음 작업을 수행
    1. arr[i]와 arr[j]의 값을 교환(swap)
        - 이렇게 함으로써 새로운 순열을 만들 수 있게 됨
    2. dfs(i + 1, arr)를 호출하여 재귀적으로 다음 인덱스에서 순열 구함
        - 즉, 한 단계 더 깊이 들어가서 다음 숫자를 순열에 추가
    3. dfs 함수가 종료되면 다시 arr[i]와 arr[j]를 원래 상태로 되돌림 (swap 복구)
        - 이는 백트래킹의 핵심으로, 다른 경로를 탐색하기 전에 배열을 원래 상태 되돌림
7. 초기 dfs(0, nums)를 호출하여, 숫자 배열 nums의 첫 번째 요소부터 순열 생성 시작
8. 모든 재귀 호출이 끝나면, result 배열을 반환하여 결과를 반환
    - result 배열에는 nums 배열의 모든 가능한 순열이 저장

## 알아둬야 할 것!

1. **백트래킹(Backtracking)의 기본 원리**
    - **탐색 후 복구**
        - 백트래킹의 핵심은 탐색할 때마다 선택을 기록하고, 다시 돌아올 때(백트래킹) 그 선택을 되돌린다는 것이다.
        - 각 단계에서 가능성을 탐색하고, 실패하거나 새로운 가능성을 탐색해야 할 때 이전 상태로 복구하는 과정이 중요하다.
    - **재귀를 통한 깊이 우선 탐색(DFS)**
        - 순열 문제는 DFS로 각 레벨에서 가능한 선택을 모두 탐색하는 방식으로 풀 수 있음을 이해해야 한다.
2. **순열의 개수와 시간 복잡도**
    - 주어진 배열의 크기가 `n`일 때, 가능한 순열의 수는 `n!`(팩토리얼)이다.
    - 즉, 배열의 크기가 커질수록 가능한 경우의 수가 매우 많아져 시간이 급격히 증가한다.
    - 따라서 시간 복잡도가 `O(n!)`임을 이해하고, 순열 문제의 특성상 이 알고리즘이 큰 입력에 대해 비효율적일 수 있음을 기억해야 한다.
3. **스왑(swap)을 사용한 순열 생성**
    - 배열에서 두 숫자를 교환(swap)하는 방식으로 순열을 생성하는 방법은 순열을 구하는 효과적인 테크닉이다.
    - 각 단계에서 스왑을 통해 숫자의 순서를 바꿔가며 새로운 순열을 만드는 과정을 잘 기억해두면, 다른 순열 문제나 변형된 문제를 해결할 때 응용할 수 있다.
4. **배열과 문자열 모두에 응용 가능**
    - 숫자 배열뿐만 아니라 문자열에도 같은 논리를 적용할 수 있다.
    - 순열 문제는 숫자, 문자열 등 어떤 타입이든 동일한 개념으로 해결할 수 있다는 점을 이해해두면 좋다.

## 회고

처음에는 복잡해 보였지만, 스왑(swap)을 활용한 순열 생성 방식이 매우 직관적이었고,

이를 통해 배열의 요소들을 효과적으로 탐색할 수 있었다.

또한, `O(n!)`의 시간 복잡도를 가진 순열 문제는 입력 크기가 클수록 시간이 급격히 늘어난다는 것을 실감할 수 있었고, 이 점에서 **알고리즘의 효율성**도 고민하게 됐다.

앞으로 비슷한 순열 문제뿐만 아니라 백트래킹을 요구하는 문제를 풀 때 더 자신감을 가질 수 있을 것 같다!
