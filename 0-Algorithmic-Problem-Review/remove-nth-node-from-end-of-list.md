## [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

## 주요 포인트

- 연결 리스트(Linked List)의 구조
    - 연결 리스트는 각 노드가 자신의 다음 노드를 가리키는 방식으로 연결되어 있는 데이터 구조이다.
    - 각 노드는 `값(value)`과 `다음 노드를 가리키는 포인터(next)`로 구성된다.
- 더미 노드(dummy node)의 사용
    - 리스트의 **첫 번째 노드를 삭제할 수 있는 상황**을 쉽게 처리하기 위해 **더미 노드**를 추가한다.
    - 더미 노드는 리스트의 맨 앞에 임시로 추가된 노드로, 실제 값과는 관계없이 리스트를 단순하게 조작할 수 있게 도와준다.
- Two-pointer (두 포인터) 기법
    - 두 개의 포인터(`first`, `second`)를 사용하여 한 번의 순회로 리스트 내에서 **뒤에서 N번째 노드**를 찾아 삭제할 수 있다.
    - `first` 포인터를 먼저 N+1 칸 이동한 후, `first`와 `second`를 함께 이동시키면서 `first`가 끝에 도달할 때 `second`는 삭제할 노드의 바로 앞에 위치하게 된다.
- 노드 삭제 원리
    - 특정 노드를 삭제하기 위해서는 **이전 노드의 `next`를 삭제할 노드의 다음 노드로 연결**해야 한다.

## 나의 코드

```jsx
var removeNthFromEnd = function(head, n) {
   let dummy = new ListNode(0);
  dummy.next = head;
  let first = dummy;
  let second = dummy;
  
  for (let i = 1; i <= n + 1; i++) {
    first = first.next;
  }
  
  while (first !== null) {
    first = first.next;
    second = second.next;
  }
  
  second.next = second.next.next;
  
  return dummy.next;
};
```

## 나의 수도 코드

1. 리스트의 첫 번째 노드가 삭제될 경우를 고려하여 더미 노드를 사용한다.
2. 더미 노드는 편의를 위해 사용되는 임시 노드로, `dummy.next`를 실제 리스트의 `head`로 설정한다.
3. `first`와 `second` 포인터를 모두 더미 노드에 위치시킨다. 
4. `first` 포인터를 N + 1칸 앞으로 이동시켜서, `first`와 `second` 사이에 N칸의 간격을 만든다. 이 간격은 뒤에서 N번째 노드를 찾아내는 데 필요하다.
5. `first`가 리스트의 끝에 도달할 때까지 `first`와 `second`를 한 칸씩 이동시킨다.
6. `second` 포인터의 `next`를 `second.next.next`로 설정하여 뒤에서 N번째 노드를 리스트에서 제외한다.
7. 더미 노드의 다음 노드(`dummy.next`)를 반환합니다. 이는 리스트의 새 `head`이다.

## 알아둬야 할 것!

1. 노드 삭제의 원리
    - **노드를 삭제**하기 위해서는 그 노드를 가리키는 **이전 노드의 포인터(`next`)** 를 **삭제할 노드의 다음 노드**로 연결해주면 된다.
    - 예를 들어, `second.next = second.next.next;`는 `second`가 가리키고 있는 노드의 **다음 노드를 건너뛰고** 그 다음 노드를 가리키게 만들어, 삭제하는 방식이다.
    - **`first = first.next`나 `second = second.next`**
        - 이는 단순히 **포인터를 이동시키는 작업이**다.
        - 포인터가 가리키는 노드를 다음 노드로 바꾸는 것일 뿐, **리스트의 연결 구조에는 아무런 영향을 미치지 않는다**.
        - 리스트 자체는 그대로 유지된다.
    - **`first.next = first.next.next`**
        - 이 코드는 **리스트의 연결 구조를 실제로 변경한**다.
        - 특정 노드를 건너뛰어 **노드를 삭제**하거나 **리스트의 구조를 변경**하는 작업이다.
    - **`first = first`**
        - 이 코드는 아무런 변화를 일으키지 않는다.
        - `first`를 `first`로 유지하는 것일 뿐, 리스트의 구조나 포인터 상태에는 아무런 영향을 미치지 않습니다.
2. 핵심 개념: 참조(Reference)에 의한 연결
    - JavaScript에서 **객체**나 **노드**는 참조(reference)에 의해 연결된다.
    - 하나의 변수가 객체를 가리키고 있으면, 다른 변수가 그 객체를 가리키게 할 수도 있고, 이 경우 두 변수는 **같은 객체를 참조**하게 된다.
    - 만약 그 객체의 내부 데이터가 변경되면, 그 데이터를 참조하는 모든 변수에서 변경 사항이 반영된다.
3. `dummy`와 `second`의 관계
    - **`dummy`와 `second`는 서로 다른 변수이지만**,
        - **같은 연결 리스트 구조를 참조**하고 있다.
        - `dummy`는 연결 리스트의 첫 번째 노드를 가리키고 있고,
        - `second`는 리스트 중간의 특정 노드를 가리키고 있는 상황이다.
    - **리스트의 노드들이 참조에 의해 연결되어 있기 때문에**, `second`가 가리키는 노드의 연결을 바꾸면, 그 변화는 리스트 전체에 영향을 미친다.

## 회고

1.  `next`의 기본 개념
    
    연결 리스트에서 각 노드는 자신의 **다음 노드**를 가리키고 있다. `next`는 그 다음 노드를 가리키는 포인터로, 리스트 내에서 이동하거나 순회할 때 가장 기본적으로 사용되는 요소다. 이 문제를 풀면서 `first = first.next`라는 코드는 단순히 **현재 위치에서 다음 위치로 이동**하는 것임을 다시 한 번 명확히 알게 되었다.
    
    포인터를 이동시키는 이 동작은 **리스트의 구조에는 영향을 미치지 않고**, 단지 내가 현재 가리키는 위치가 바뀌는 것이었다. 즉, **리스트의 본질적인 연결은 변하지 않으면서 포인터가 옮겨가는** 기본적인 동작임을 이해했다.
    
2.  `next.next`의 의미와 역할
    
    반면, `next.next`는 현재 노드의 **다음 노드의 다음 노드를 가리키는 것**으로, **연결 리스트의 변형**에 직접적으로 사용된다.
    
    - `first.next = first.next.next`라는 코드를 통해 **중간에 있는 노드를 건너뛰어** 리스트의 연결을 변경할 수 있었다. 이 코드는 단순히 포인터를 이동시키는 것이 아니라, **리스트의 구조 자체를 수정**하는 작업이었다. 즉, **현재 노드의 다음 노드가 가리키는 것을 건너뛰고 그 이후 노드로 바로 연결**시켜 중간 노드를 제외하는 방식으로 리스트를 변화시켰다.
    
    이 작업을 통해 **리스트에서 특정 노드를 삭제**하는 동작이 이루어졌다. 이 과정에서 `next.next`라는 개념이 노드를 건너뛰게 하는 역할을 한다는 점을 명확히 이해하게 되었다.
    
3.   포인터 이동과 리스트 구조 변화의 차이
    
    이번 문제를 풀면서 가장 큰 깨달음은 포인터 이동과 리스트 구조 변경의 차이를 확실히 구분하는 것이었다. `first = first.next`는 단순히 포인터를 다음 노드로 옮기는 것일 뿐 리스트의 구조에는 영향을 미치지 않는다. 이는 리스트를 순회하거나 탐색할 때 사용되는 매우 기본적인 동작이다.
    
    하지만, `first.next = first.next.next`는 그와 다르게 리스트의 연결을 수정하여 구조를 변형한다. 이는 리스트에서 노드를 삭제하거나, 건너뛰는 동작을 수행할 때 매우 중요한 작업이다. 두 코드가 동작하는 원리와 그 결과가 다르다는 점을 다시 한 번 명확히 구분하게 되었다.
    
4.  배운 점과 앞으로의 방향
    
    이번 문제를 통해 `next`와 `next.next`의 의미를 깊이 있게 이해하게 되었다. 단순한 포인터 이동이 아니라, **리스트의 구조를 수정하는 작업이 어떻게 이루어지는지**를 명확히 알게 되었다는 점이 가장 큰 수확이었다.
    
    앞으로도 연결 리스트 문제를 풀 때 **포인터의 이동과 리스트의 연결 변경**을 명확히 구분하고, 이를 효율적으로 사용할 수 있도록 더욱 연습할 필요가 있겠다고 느꼈다. 더 나아가, 이 개념을 활용해 **더 복잡한 연결 리스트 변형 문제**나 **자료 구조 문제**에서도 자신 있게 문제를 풀 수 있을 것 같다.
