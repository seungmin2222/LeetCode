## [Word Search](https://leetcode.com/problems/word-search/)

이 문제는 주어진 `m x n` 크기의 문자 그리드에서 특정 단어가 인접한 셀들(가로 또는 세로)로 구성될 수 있는지 확인하는 문제이다.

## 주요 포인트

- **DFS (Depth First Search, 깊이 우선 탐색)**
    - 재귀적으로 깊이 있게 탐색을 진행하며, 이 문제에서는 인접한 셀들을 탐색하는 데 활용된다.
    - 특히, 재귀 호출과 백트래킹(backtracking)을 통해 특정 조건을 만족하는 경로를 찾는 데 적합하다.
- **백트래킹 (Backtracking)**
    - 문제에서는 이미 방문한 셀을 다시 사용할 수 없기 때문에 백트래킹을 통해 올바른 경로만 찾도록 한다.
    - 즉, 잘못된 경로를 탐색할 경우, 그 경로에서 빠져나와 다른 경로를 탐색하는 것이 백트래킹의 핵심이다.

## 나의 코드

```jsx
var exist = function(board, word) {
  function dps (x,y, i) {
    if (i === word.length) return true;
    
    if (x < 0 || y < 0 || x >= board.length || y >= board[0].length || board[x][y] !== word[i]) {
      return false;
    }
    
    const temp = board[x][y];
    board[x][y] = '#';
    
    const found = dps(x + 1, y, i + 1) ||
                  dps(x - 1, y, i + 1) ||
                  dps(x, y + 1, i + 1) ||
                  dps(x, y - 1, i + 1);
    
    board[x][y] = temp;
    
    return found;
  }  
  
  for (let i = 0; i < board.length; i++) {
    for (let j = 0; j < board[0].length; j++) {
      if (board[i][j] === word[0] && dps(i, j, 0)) {
        return true;
      }
    }
  }
  
   return false;
  
};
```

## 나의 수도 코드

1. **dps 함수 정의**
    - 함수는 현재 위치 `(x, y)`와 찾고자 하는 `word`의 현재 문자 인덱스 `i`를 인자로 받음.
    - `i`가 `word`의 길이와 같아지면 모든 문자를 찾았으므로 `true` 반환.
    - 현재 위치가 그리드 경계를 벗어나거나, 현재 위치의 문자가 `word[i]`와 다르면 `false` 반환.
2. **현재 위치 문자 저장 및 방문 처리**
    - 현재 위치 `(x, y)`의 문자를 임시로 `temp`에 저장하고, 해당 위치를 `#`로 마킹하여 방문했음을 표시.
3. **상하좌우 방향으로 재귀 호출 (DFS 탐색)**
    - `dps` 함수를 상하좌우로 호출하여 다음 문자가 맞는지 확인.
    - 각 방향에서 `dps`가 `true`를 반환하면 탐색 성공이므로 `true` 반환.
4. **현재 위치 복구**
    - 현재 위치에서 탐색을 마치면 다시 원래의 문자로 복원 (`board[x][y] = temp`).
5. **보드의 모든 위치에서 탐색 시작**
    - `board`의 모든 셀을 순회하면서 첫 번째 문자가 `word[0]`과 일치하는 셀을 찾으면 그 위치에서 `dps`를 호출하여 단어를 찾기 시작.
    - 단어를 찾으면 즉시 `true` 반환, 그렇지 않으면 탐색을 계속함.
6. **탐색이 끝난 후 결과 반환**
    - 모든 탐색이 끝난 후에도 단어를 찾지 못하면 `false` 반환.

## 알아둬야 할 것!

1. **DFS와 백트래킹의 응용**
    - 이번 문제를 풀면서 DFS(깊이 우선 탐색)를 통해 그리드에서 가능한 모든 경로를 탐색하고, 백트래킹(backtracking) 기법을 적용하여 이미 방문한 경로는 되돌아가지 않도록 처리하는 방식을 배웠다.
    - 특정 조건을 만족하지 않을 때, 이전 상태로 되돌아가는 백트래킹의 개념을 실전에서 어떻게 적용할 수 있는지 확인할 수 있었다.
2. **경계 처리와 재귀 함수 사용법**
    - 2D 배열에서 인덱스가 범위를 벗어나지 않도록 경계 처리하는 방법을 다시 복습할 수 있었다. 이 문제에서는 배열의 경계를 벗어나는 조건을 잘 설정해야 오류를 방지할 수 있음을 배웠다.
    - 재귀적으로 함수를 호출하면서, 문제를 점진적으로 해결해 나가는 방식에 대한 이해를 높일 수 있었다.
3. **최소한의 리소스로 조건 처리하기**
    - 방문한 셀을 잠시 다른 값(`'#'`)으로 표시해 두고, 탐색이 끝나면 다시 원래 값으로 복원하는 방법을 배웠다. 이를 통해 추가적인 데이터 구조를 사용하지 않고도 문제를 해결할 수 있음을 알게 되었다.

## 회고

이번 문제를 풀면서 DFS와 백트래킹의 중요성을 다시 한 번 체감했다.

이 문제는 단순히 모든 경로를 탐색하는 것이 아니라, 중복되지 않게 특정 경로를 추적하면서 조건을 만족할 때만 경로를 확장하는 것이 핵심이었다.

초반에는 모든 방향을 무조건 탐색하고 그 결과를 반환하려고 했지만, 재귀 호출이 불필요하게 많이 발생해 비효율적일 수 있음을 깨달았다.

가장 어려웠던 부분은 보드의 경계값 처리를 정확하게 하는 것과, 한 번 방문한 셀을 다시 방문하지 않게 설정하는 것이었는데, 이를 해결하고 나니 코드가 훨씬 간결해졌다.

이 문제를 통해 DFS와 백트래킹 기법을 실전에서 적용할 수 있는 방법을 확실하게 이해할 수 있었고, 경계값 처리와 재귀 함수의 활용법을 익히는 데 큰 도움이 되었다.
