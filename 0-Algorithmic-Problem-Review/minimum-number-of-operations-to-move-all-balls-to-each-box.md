## [Minimum Number of Operations to Move All Balls to Each Box](https://leetcode.com/classic/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/description/)

각 상자를 기준으로 모든 공을 해당 상자로 이동시키는 데 필요한 최소 작업 횟수를 구하는 문제이다.

## 주요 포인트

1. 공의 개수를 누적하며 각 위치에서 왼쪽으로부터 필요한 이동 작업 수를 계산.
2. 동일하게 공의 개수를 누적하며 오른쪽으로부터 필요한 작업 수를 더함.
3. 두 방향에서의 이동 작업 수를 합쳐 최종 결과를 구함.

## 나의 코드

```jsx
var minOperations = function(boxes) {
    const n = boxes.length;
    const answer = new Array(n).fill(0);
    
    let count = 0;
    let steps = 0;
    
    for (let i = 0; i < n; i++) {
        answer[i] += steps;
        count += boxes[i] === '1' ? 1 : 0;
        steps += count;
    }
    
    count = 0;
    steps = 0;
    
    for (let i = n - 1; i >= 0; i--) {
        answer[i] += steps;
        count += boxes[i] === '1' ? 1 : 0;
        steps += count;
    }
    
    return answer;
};
```

## 나의 수도 코드

1. `boxes`라는 문자열을 받는다.
2. **변수 초기화**
    - `n`: 상자의 개수.
    - `answer`: 길이가 `n`인 배열 (0으로 초기화).
    - `count`와 `steps`: 공 개수와 이동 횟수(0으로 초기화).
3. **왼쪽에서 오른쪽으로 계산**
    - 각 상자 `i`에 대해
        - `answer[i]`에 현재 `steps` 값을 추가.
        - 현재 상자가 공이면 `count` 증가.
        - `steps`에 `count`를 더함.
4. **오른쪽에서 왼쪽으로 계산**
    - 각 상자 `i`에 대해 (뒤에서 앞으로)
        - `answer[i]`에 현재 `steps` 값을 추가.
        - 현재 상자가 공이면 `count` 증가.
        - `steps`에 `count`를 더함.
5. **결과 반환**: 계산된 `answer` 배열.

## 시간 복잡도

- **왼쪽에서 오른쪽으로 계산**
    - `for` 루프는 `n`번 반복된다.
    - 각 반복에서 O(1)의 작업만 수행하므로 총 O(n).
- **오른쪽에서 왼쪽으로 계산**
    - `for` 루프는 `n`번 반복된다.
    - 각 반복에서 O(1)의 작업만 수행하므로 총 O(n).

**총 시간 복잡도는** O(n) + O(n) = **O(n)**.

## 공간 복잡도

- **필요한 추가 메모리**
    - `answer` 배열: 크기 `n` → **O(n)**.
    - 나머지 변수들(`count`, `steps`): 상수 공간 → **O(1)**.

**총 공간 복잡도는** **O(n)**.

## 알아둬야 할 것!

1. **누적 합 (Prefix Sum)**

- 누적 합은 배열의 각 위치까지의 합을 계산하는 기법이다.
- 이 문제에서 왼쪽에서 오른쪽, 오른쪽에서 왼쪽으로 공의 이동 횟수를 계산할 때 누적 합 개념이 사용된다.
- 이전에 계산한 결과(`steps`)에 현재 공의 개수(`count`)를 더하며 작업을 누적합니다.

2. **이동 횟수 계산 (Weighted Sum)**

- 각 상자에서 특정 방향으로 공의 이동 횟수를 계산하는 방식이다.
- 공의 위치에 따라 이동 거리가 달라지므로 거리와 공의 개수를 곱해서 더한다.
- 이 문제에서는 공의 위치와 거리를 기반으로 왼쪽 및 오른쪽에서 최소 작업 횟수를 계산한다.

3. **이중 반복문 최적화**

- 처음 문제를 접근할 때 공 하나씩 모든 상자에 대해 반복문을 실행하면 O(n²)의 시간 복잡도가 된다.
- 이 문제에서는 각 방향으로 **단일 반복문**(왼쪽 → 오른쪽, 오른쪽 → 왼쪽)을 사용해 최적화(O(n))를 달성한다.

## 회고

이번 문제는 문자열을 기반으로 최소 이동 횟수를 계산하는 최적화된 알고리즘을 설계하는 데 중점을 두었다.

누적 합을 활용해 단일 반복문(O(n))으로 최적화할 수 있었다.

방향별로 공의 이동을 계산하는 아이디어가 핵심이었고, 이를 통해 효율적인 풀이를 구현할 수 있었다.

문제를 풀며 배열, 누적 계산, 시간 복잡도 최적화의 중요성을 다시 한번 깨달을 수 있었다.
