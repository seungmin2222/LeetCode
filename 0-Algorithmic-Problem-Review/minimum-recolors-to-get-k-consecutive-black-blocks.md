## [Minimum Recolors to Get K Consecutive Black Blocks](https://leetcode.com/classic/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)

이 문제는 주어진 문자열에서 연속된 'B' 블록이 k개가 되도록 최소한 몇 번의 변환이 필요한지 구하는 문제이다.

## 주요 포인트

1. 변환은 'W'를 'B'로 바꾸는 방식으로만 가능하다.
2. 문제를 해결하는 방법은 슬라이딩 윈도우(Sliding Window) 기법을 활용하는 것이다.
3. 슬라이딩 윈도우 기법을 사용하면, 문자열에서 길이 k의 연속된 부분을 확인하면서 최소 변환 횟수를 구할 수 있다.

## 나의 코드

```jsx
var minimumRecolors = function(blocks, k) {
    let minChanges = Infinity;
    
    for (let i = 0; i <= blocks.length - k; i++) {
        let changes = 0;
        
        for (let j = i; j < i + k; j++) {
            if (blocks[j] === 'W') {
                changes++;
            }
        }
        
        minChanges = Math.min(minChanges, changes);
    }
    
    return minChanges;
};
```

## 나의 수도 코드

1. 슬라이딩 윈도우 사용
문자열을 한 칸씩 밀면서, 길이가 k인 연속된 부분을 확인한다.
2. 연속된 부분의 변환 횟수 계산
각 연속된 부분에서 'B'의 개수를 세고, 'B'가 아닌 'W'의 개수를 세서 해당 부분에서 'W'를 'B'로 바꾸는 횟수를 구한다.
3. 최소 변환 횟수 구하기
모든 연속된 부분을 확인하면서, 가장 적은 변환 횟수를 기록한다.

## 시간 복잡도

1. 슬라이딩 윈도우를 사용하여 `k` 길이의 부분 문자열을 검사.
    - 주어진 문자열 `blocks`의 길이를 `n`이라고 할 때, 가능한 연속된 길이 `k` 부분을 살펴보는 위치는 총 `n - k + 1` 번.
    - 각 부분에서 'W'의 개수를 세는데, 이는 최대 `k`번의 연산이 필요.

따라서, 전체 시간 복잡도는 O((n - k + 1) * k) = O(n * k)이다.

## 공간 복잡도

- 이 알고리즘은 슬라이딩 윈도우 기법을 사용하며, 별도로 추가적인 배열이나 자료구조를 사용하지 않기 때문에 O(1)의 공간을 추가적으로 사용한다.
- 변수 `minChanges`와 `changes`는 상수 공간만 필요하다.

따라서, 공간 복잡도는 O(1)이다.

## 알아둬야 할 것!

- 슬라이딩 윈도우(Sliding Window) : 연속된 부분 배열이나 부분 문자열을 다룰 때 유용한 기법으로, 고정된 크기의 창을 사용해 한 번에 한 칸씩 이동하며 값을 처리하는 방법.
- 시간 복잡도 최적화 : 주어진 문제에서 가능한 모든 경우를 검사하는 것이 아닌, 부분 문자열이나 배열의 일부를 슬라이딩 윈도우 기법을 통해 효율적으로 계산하여 시간 복잡도를 줄인다.
- 그리디 알고리즘 : 최소 변환 횟수를 구하는 문제에서 매번 변환 횟수를 최소화하는 방향으로 선택하는 방식으로, 슬라이딩 윈도우와 결합하여 최적의 해를 찾는다.
- 부분 문자열 탐색 : 연속된 부분을 탐색할 때 사용하는 다양한 기법을 이해하는 것이 중요하다.

## 회고

이 문제는 슬라이딩 윈도우 기법을 활용하여 효율적으로 풀 수 있는 문제였다.

처음에는 모든 부분을 확인하면서 비교적 비효율적인 방법을 생각할 수 있지만, 슬라이딩 윈도우를 통해 시간 복잡도를 최적화할 수 있었다. 또한, 그리디 알고리즘의 개념을 활용해 변환 횟수를 최소화하는 방법을 찾을 수 있었다.

앞으로 비슷한 문제에서는 슬라이딩 윈도우 기법을 적극적으로 활 용할 필요가 있겠다고 느꼈다.
