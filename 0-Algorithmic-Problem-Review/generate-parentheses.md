## [**Generate Parentheses**](https://leetcode.com/problems/generate-parentheses/)

이 문제는 주어진 `n` 쌍의 괄호를 사용해 올바르게 짝지어진 괄호 조합을 모두 생성하는 문제이다.

괄호가 열리면 반드시 닫혀야 하며, 이를 만족하는 모든 경우를 출력해야 한다.

## 주요 포인트

1. **백트래킹(Backtracking)**
    - 해를 찾아가는 과정에서 조건을 만족하지 않는 경우, 그 경로를 포기하고 다른 경로를 시도하는 알고리즘 기법.
2. **재귀(Recursion)**
    - 문제를 작은 문제로 나누어 풀기 위한 방법으로, 함수가 자기 자신을 호출하는 방식.
3. **올바른 괄호 조합**
    - 열린 괄호 '('의 수가 닫힌 괄호 ')'의 수보다 많지 않아야 하며, 쌍을 이룬 상태여야 함.

## 나의 코드

```jsx
var generateParenthesis = function(n) {
  const arr = [];
  
  function backtracking (braket, openNum, closeNum) {
    if (braket.length === n * 2) {
      arr.push(braket);
      return;
    }
    
    if (openNum < n) {
      backtracking(braket + '(', openNum + 1, closeNum);
    }
    
    if (closeNum < openNum) {
      backtracking(braket + ')', openNum, closeNum + 1);     
    }
  }
  
  backtracking('', 0, 0);
  
  return arr;
};
```

## 나의 수도 코드

1. `generateParenthesis(n)` 함수를 호출하여 결과를 저장할 빈 리스트 `result`를 생성.
2. `backtrack(현재 문자열, 열린 괄호 개수, 닫힌 괄호 개수)` 함수를 정의.
    - 만약 `현재 문자열`의 길이가 `n * 2`일 경우
        - `result` 리스트에 `현재 문자열`을 추가하고 함수를 종료.
    - 만약 `열린 괄호 개수`가 `n`보다 적다면
        - `현재 문자열`에 `'('`를 추가하고, `열린 괄호 개수`를 증가시켜 `backtrack` 함수를 재귀 호출.
    - 만약 `닫힌 괄호 개수`가 `열린 괄호 개수`보다 적다면
        - `현재 문자열`에 `')'`를 추가하고, `닫힌 괄호 개수`를 증가시켜 `backtrack` 함수를 재귀 호출.
- `backtrack("", 0, 0)`으로 백트래킹을 시작.
- `result` 리스트를 반환.

## 다른 사람의 풀이

```jsx
var generateParenthesis = function(n) {
    const result = [];
    const queue = [{ str: "", open: 0, close: 0 }];
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.str.length === 2 * n) {
            result.push(current.str);
            continue;
        }

        if (current.open < n) {
            queue.push({ str: current.str + '(', open: current.open + 1, close: current.close });
        }

        if (current.close < current.open) {
            queue.push({ str: current.str + ')', open: current.open, close: current.close + 1 });
        }
    }
    
    return result;
};
```

## 다른 사람의 수도 코드

1. `queue`는 생성할 괄호 조합의 상태를 저장. 
2. 초기에는 빈 문자열과 `open`, `close` 카운터를 모두 0으로 설정한 객체를 큐에 넣음.
3. `while` 루프는 큐가 비어있지 않을 동안 반복.
    - 큐의 첫 번째 요소를 꺼내 현재 상태로 괄호 문자열을 생성.
    - 문자열 길이가 `2 * n`이 되면, 그 괄호 조합은 유효하므로 결과 리스트에 추가.
    - 열린 괄호의 개수가 `n`보다 작으면 열린 괄호 `'('`을 추가한 상태를 큐에 넣고,
    - 닫힌 괄호의 개수가 열린 괄호보다 적으면 닫힌 괄호 `')'`를 추가한 상태를 큐에 넣음.
4. BFS 방식으로 차례대로 모든 가능한 괄호 조합을 생성.

## 나의 코드와의 차이점

### **알고리즘 방식의 차이**

- **나의 코드**
    - **DFS(깊이 우선 탐색) + 백트래킹**
        - 나의 코드는 깊이 우선 탐색(DFS) 방식이다.
        - 재귀적으로 괄호 조합을 만들면서 유효하지 않은 경우(열린 괄호 수가 부족하거나 닫힌 괄호 수가 초과하는 경우)를 배제한다.
        - 올바른 조합을 찾으면 결과 배열에 추가하고 재귀 호출을 통해 되돌아가면서 다른 경우도 시도한다.
        - **재귀를 사용**하여 괄호 문자열을 하나씩 생성하고, 유효한 조합이 완성될 때마다 리스트에 추가한다.
- **다른 사람의 코드**
    - **BFS(너비 우선 탐색) + 큐**
        - **다른 사람의 코드**는 너비 우선 탐색(BFS) 방식이다.
        - 큐를 사용하여 괄호를 순차적으로 추가하면서 모든 가능한 경로를 동시에 탐색한다.
        - **반복문과 큐를 사용**하여 괄호 문자열을 생성하며, 열린 괄호와 닫힌 괄호의 개수를 함께 추적해 모든 가능한 조합을 탐색한다.

## 알아둬야 할 것!

1. **백트래킹(Backtracking)**
    - 백트래킹은 유효하지 않은 경로를 탐색하는 도중에 중단하고, 다른 경로를 탐색하는 방식이다.
    - 괄호를 만들다가 열고 닫는 조건이 맞지 않으면 해당 경로를 포기하고, 다른 가능한 경로를 탐색한다.
2. **DFS(Depth-First Search, 깊이 우선 탐색)**
    - DFS는 재귀를 이용해 한 경로를 끝까지 탐색한 후 다른 경로를 탐색하는 방식이다.
    - 이 문제에서, 괄호를 하나씩 추가하며 깊이 들어가고, 잘못된 조합이면 다시 되돌아가 다른 경로를 시도하는 방식이다.
3. **BFS(Breadth-First Search, 너비 우선 탐색)**
    - BFS는 여러 경로를 동시에 탐색하는 방식이다.
    - 호 문제를 BFS로 해결할 경우 큐(queue)를 사용해 가능한 모든 상태를 저장하며, 한꺼번에 여러 경로를 고려한다.
4. **괄호의 유효성 조건**
    - 열린 괄호는 항상 닫힌 괄호보다 많아야 하며, 닫힌 괄호가 열린 괄호보다 많아질 수 없다.
    - 괄호 조합이 완료되기 위해서는 `n` 쌍의 괄호가 모두 올바르게 열리고 닫혀야 한다.
5. **문자열 조작(String Manipulation)**
    - 괄호 조합을 만들기 위해 문자열을 다루는 방법을 알아야 한다. 괄호를 추가할 때는 문자열에 `'('` 또는 `')'`를 이어붙이는 방식으로 처리한다.

## 회고

이번에 해결한 **Generate Parentheses** 문제는 재귀와 백트래킹을 깊이 이해할 수 있었던 좋은 기회였다.

`n` 쌍의 괄호를 사용해 올바르게 짝지어진 괄호 조합을 구하는 문제로, 처음에는 복잡하게 느껴졌지만 문제의 본질을 파악하면서 점차 명확해졌다.

**백트래킹과 재귀**에 대한 개념을 확고히 할 수 있었으며, 문제 해결에서 중요한 것은 복잡한 문제를 단계적으로 나누어 생각하는 방법이라는 점을 배웠다.

앞으로도 다양한 알고리즘 문제를 해결하며 이러한 기법을 더 깊이 탐구할 예정이다.
