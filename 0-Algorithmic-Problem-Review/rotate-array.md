## [**Rotate Array**](https://leetcode.com/problems/rotate-array)

이 문제는 배열 `nums`를 오른쪽으로 `k`만큼 회전시키는 것이다.

## 주요 포인트

**배열 길이와 `k`의 관계**

- `k`가 배열의 길이보다 큰 경우에도 회전이 반복된다는 점에 주의해야 한다.
- 실제로 배열을 `n`번 이상 회전하는 것은 `k % n`번만 회전하는 것과 같다.
- ex)길이가 7인 배열을 10번 회전시키는 것은 3번 회전시키는 것과 같다.

## 나의 코드

```jsx
var rotate = function(nums, k) {
  for (let i = 0; i < k; i++) {
    const pop = nums.pop();
    nums.unshift(pop);
  }
  
  return nums;
};
```

## 나의 수도 코드

1. 주어진 `k`번 동안 배열의 요소들을 오른쪽으로 회전.
2. 배열 `nums`의 마지막 요소를 제거하고, 그 값을 변수 `pop`에 저장.
3. `pop`에서 제거한 값을 배열 nums 맨 앞에 삽입.

## 다른 사람의 풀이

```jsx
var rotate = function(nums, k) {
    k = k % nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
};

var reverse = function(nums, start, end) {
    while (start < end) {
        let temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;
        end--;
    }
};
```

## 다른 사람의 코드 해석

1. **첫 번째 뒤집기**: 배열 전체를 뒤집는다.
    - 전체 배열을 뒤집으면, 처음에 있던 요소들이 모두 뒤로 가고, 뒤에 있던 요소들이 앞으로 오게 된다.
    
    ```
    [1, 2, 3, 4, 5, 6, 7]  →  [7, 6, 5, 4, 3, 2, 1]
    ```
    
2. **두 번째 뒤집기**: 배열의 처음 `k`개의 요소를 다시 뒤집는다.
    - 이 단계에서 배열의 앞부분 `k`개의 요소를 다시 뒤집으면, 원래 배열의 마지막 `k`개의 숫자가 원래 순서대로 앞으로 오게 된다.
    
    ```
    [7, 6, 5, 4, 3, 2, 1]  →  [5, 6, 7, 4, 3, 2, 1]
    ```
    
3. **세 번째 뒤집기**: 배열의 나머지 부분(`k` 이후의 요소들)을 다시 뒤집는다.
    - 마지막으로, 나머지 부분을 다시 뒤집으면 원래 배열의 앞부분이 원래 순서로 뒤로 가게 된다.
    
    ```
    [5, 6, 7, 4, 3, 2, 1]  →  [5, 6, 7, 1, 2, 3, 4]
    ```
    

### `reverse` 함수 설명

```jsx
var reverse = function(nums, start, end) {
    while (start < end) {
        let temp = nums[start];  // 임시 변수에 nums[start] 값을 저장
        nums[start] = nums[end];  // nums[start]에 nums[end] 값을 대입
        nums[end] = temp;  // nums[end]에 임시 변수(temp)에 저장한 nums[start] 값을 대입
        start++;  // 시작점을 한 칸 오른쪽으로 이동
        end--;  // 끝점을 한 칸 왼쪽으로 이동
    }
};
```

## 나의 코드와 비교 요약

| 항목 | 주어진 코드 (`pop`, `unshift`) | 최적화된 코드 (세 번 뒤집기) |
| --- | --- | --- |
| **동작 방식** | 마지막 요소를 `pop` 후 맨 앞에 `unshift` | 배열을 세 번 뒤집음 |
| **시간 복잡도** | O(k * n) | O(n) |
| **공간 복잡도** | O(1) | O(1) |
| **효율성** | 비효율적 (특히 `k`가 클 때) | 매우 효율적 |
| **추가 공간 사용 여부** | 없음 (in-place) | 없음 (in-place) |
| **핵심 문제점** | 배열을 매번 `unshift`로 이동시키는 비효율성 | 효율적인 회전 구현 |

### 결론

- **주어진 코드**는 작은 `k`값일 때는 잘 동작하지만, 배열의 크기와 `k`가 커질수록 비효율적이다.
- `k`번 반복하면서 배열의 모든 요소를 매번 이동시키는 작업이 성능에 큰 영향을 미친다.
- **최적화된 코드**는 O(n) 시간 복잡도로, 배열을 세 번 뒤집는 방법을 사용하여 효율적으로 문제를 해결할 수 있다.
- `k`가 커지더라도 일정한 성능을 유지합니다.

## 알아둬야 할 것!

1. **배열 회전 문제**
    - 배열을 오른쪽으로 `k`번 회전시키는 문제는 배열을 효율적으로 재배치하는 방법을 요구함.
2. **효율성**
    - 주어진 방식(`pop()`과 `unshift()`)은 시간 복잡도가 O(k * n)으로 비효율적이며, 큰 배열에서는 성능 문제가 발생할 수 있음.
    - 최적화된 방식은 배열을 **세 번 뒤집는 방법**으로 시간 복잡도가 O(n)으로 매우 효율적임.
3. **핵심 개념**
    - **pop()과 unshift()**: 배열 끝에서 요소를 제거하고 맨 앞에 삽입하는 방식. 비효율적일 수 있음.
    - **세 번 뒤집기**: 배열 전체를 뒤집고, 회전할 부분과 나머지 부분을 각각 뒤집어 효율적으로 회전시키는 방법. `in-place`로 처리 가능.
4. **시간/공간 복잡도**
    - 최적화된 방법의 시간 복잡도는 O(n), 공간 복잡도는 O(1)로 매우 효율적.

## 회고

이번 배열 회전 문제를 해결하면서, 성능 최적화의 중요성을 다시 한번 깨달았다.

처음 접근한 방법은 간단했지만, 비효율적이었고 큰 배열에서는 성능 저하가 발생할 수 있었다.

최적화된 세 번 뒤집기 방법을 통해 O(n)으로 효율적으로 해결할 수 있었고, 공간 복잡도도 O(1)로 줄일 수 있었다.

앞으로는 더 효율적인 알고리즘을 고민하는 습관을 기르겠다.
