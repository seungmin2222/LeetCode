## [**Path Sum II**](https://leetcode.com/problems/path-sum-ii)

이 문제는 주어진 이진 트리에서 **루트에서 리프까지의 경로** 중 **노드 값의 합이 `targetSum`과 같은 모든 경로**를 찾아 반환하는 문제이다.

## 주요 포인트

- **이진 트리 (Binary Tree)**
    - 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리 구조. 이 문제에서는 주어진 트리를 탐색해 경로를 찾아야 함.
- **DFS (Depth-First Search)**
    - 트리나 그래프를 탐색할 때 사용하는 방법 중 하나로, 한 방향으로 끝까지 탐색한 후 백트래킹(backtracking)을 통해 다른 경로를 탐색하는 방식.
- **백트래킹 (Backtracking)**
    - DFS 과정에서 **이전 상태로 돌아가면서** 다른 경로를 탐색하는 기법. 현재 경로에서 사용된 값을 제거(`pop()`)하여 다음 경로에 영향을 주지 않도록 함.
- **재귀 (Recursion)**
    - 함수를 자기 자신 안에서 호출하는 기법으로, 트리 구조를 순회하거나 반복 작업을 처리할 때 유용함.

## 나의 코드

```jsx
var pathSum = function(root, targetSum) {
    const result = [];
    
    const dfs = (node, currentPath, sum) => {
        if (!node) return;
        
        currentPath.push(node.val);
        sum += node.val;
      
        if (!node.left && !node.right && sum === targetSum) {
          result.push([...currentPath]);
        } else {
          dfs(node.left, currentPath, sum);
          dfs(node.right, currentPath, sum); 
        }
      
        currentPath.pop();
    };
    
    dfs(root, [], 0);
    return result;
};

```

## 나의 수도 코드

1. 트리가 비어 있으면, 빈 결과를 반환한다.
2. 그렇지 않으면 빈 배열 `result`를 준비한다.
3. 현재 노드 값을 경로에 추가한다.
4. 현재까지의 합을 업데이트한다.
5. 현재 노드가 리프 노드(왼쪽과 오른쪽 자식이 없는 노드)이고, 합이 `targetSum`과 같다면 경로를 `result`에 저장한다.
6. 왼쪽 자식 노드를 재귀 호출한다.
7. 오른쪽 자식 노드를 재귀 호출한다.
8. 탐색이 끝나면, 경로에서 현재 노드를 제거하여 다른 경로 탐색에 영향을 주지 않도록 한다.
9. 모든 탐색이 끝나면 `result`에 저장된 경로들을 반환한다.

## 알아둬야 할 것!

- **DFS (Depth-First Search, 깊이 우선 탐색)**
- **경로 추적 (Path Tracking)**
- **백트래킹 (Backtracking)**
    - **DFS에서 특정 경로의 탐색이 끝난 후**, 다음 경로를 탐색하기 전에 **현재까지의 경로를 원래 상태로 되돌리는 것이 핵심이다.**
    - `currentPath.pop()`은 **현재 노드를 경로에서 제거**함으로써, 다음 경로 탐색에서 이전 경로가 영향을 주지 않도록 한다.
    - 만약 `pop()`이 없다면, 모든 경로가 서로 섞여서 잘못된 결과를 낼 수 있습니다. 예를 들어, `[5, 4, 11, 7]` 경로 탐색 후, 다시 **`7`을 제거하지 않으면** 다음 경로인 `[5, 4, 11, 2]`에 `7`이 남아있는 문제가 발생합니다.
- **재귀와 스택**
    - 재귀 호출은 내부적으로 **스택을 사용**하여 각 함수 호출의 상태(현재 노드와 경로)를 저장하고, 재귀 호출이 끝나면 **해당 스택을 해제해야 한다.**
    - `currentPath.pop()`은 **재귀 호출 스택에서 반환된 후, 현재 경로에서 마지막 요소를 제거하는 역할**을 한다.
    - 재귀가 끝난 후에는 다시 상위 호출로 돌아가기 때문에, **상위 호출에서 사용하던 경로를 그대로 유지하기 위해** `pop()`이 필요하다.

## 회고

이번 문제에서 가장 중요한 부분 중 하나는 **백트래킹**을 적절하게 처리하는 것이었는데, **`currentPath.pop()`을 놓친 점**이 문제를 정확하게 해결하지 못한 주요 원인으로 드러났다.

처음에는 경로를 추적하며 DFS를 수행하는 과정에서, 노드를 경로에 추가하는 것은 쉽게 이해했지만, **탐색이 끝난 후 경로에서 노드를 제거하는 과정**, 즉 **백트래킹의 중요성**을 간과했다.

`pop()`을 하지 않으면 **이전 경로들이 누적된 상태로 남아** 새로운 경로를 탐색할 때 영향을 미치기 때문에, 잘못된 경로들이 결과에 포함되는 문제가 발생한다.

특히, 리프 노드에 도달한 후에 자식 노드로 더 이상 내려갈 수 없을 때, **현재 경로에서 마지막 노드를 제거하는 작업**을 놓쳐서, **다음 경로 탐색이 올바르게 수행되지 않는다.**

이 경험을 통해 **재귀 호출 후 상태를 복원하는 과정**의 중요성을 다시 한번 깨달았고, 특히 **DFS에서의 백트래킹**이 경로 탐색 문제에서 어떻게 작동해야 하는지 깊이 이해하게 되었다.

앞으로는 재귀 호출이 끝날 때마다 경로를 원래대로 복원하는 **`pop()`과 같은 과정**을 놓치지 않도록 더 신중히 처리하도록 유의해야겠다.
