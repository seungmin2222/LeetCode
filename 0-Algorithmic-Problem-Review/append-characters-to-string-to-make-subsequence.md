## [Append Characters to String to Make Subsequence](https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/description/?envType=daily-question&envId=2024-06-03)

주어진 두 문자열 s와 t가 있을 때, s의 끝에 최소 몇 개의 문자를 덧붙여야 t가 s의 서브시퀀스가 되는지를 구하는 문제이다.

## 주요 포인트

t의 앞부분 중에서 이미 s에 순서대로 포함된 부분을 찾고, 남은 부분을 s의 끝에 붙여야 함.

즉, s 안에 있는 t의 가장 긴 앞부분 prefix를 찾고, t.length - 그 길이 만큼 문자를 붙이면 됨.

## 나의 코드

```tsx
var appendCharacters = function (s, t) {
    let i = 0;
    let j = 0;

    while (i < s.length && j < t.length) {
        if (s[i] === t[j]) {
            j++;
        }

        i++;
    }

    return t.length - j;
};
```

## 나의 수도 코드

1. 포인터 i, j를 0으로 초기화 (i는 s를, j는 t를 가리킴)
2. s의 끝까지 반복하면서 다음을 수행
    - 만약 s[i]와 t[j]가 같다면
        - j를 1 증가시킴 (t의 다음 문자로 이동)
    - i를 1 증가시킴 (s의 다음 문자로 이동)
3. 루프가 끝난 뒤
    - t에서 남은 문자의 개수 = t.length - j
    - 이만큼의 문자를 s 끝에 붙이면 t가 s의 subsequence가 됨
4. 그 개수를 반환

## 시간 복잡도

i는 s.length만큼 최대 이동하고 j는 t.length만큼 최대 이동함

하지만 while 루프는 한 번만 돌고, 각 반복에서 i++는 무조건 일어나니까

→ 루프는 O(s.length)만큼만 돌아감

최종 시간 복잡도는 O(n)이다.

## 공간 복잡도

1. 별도의 배열이나 자료구조 안 쓰고,
2. 변수 i, j만 사용하니까

최종 공간 복잡도는 O(1)이다.

## 알아둬야 할 것!

1. Subsequence(서브시퀀스)는 일부 문자를 삭제하되 **순서는 유지**해야 한다.
2. 두 문자열에서 한 쪽이 다른 쪽의 서브시퀀스인지 판별할 땐 **투 포인터 방식**이 효과적이다.
3. s 안에 있는 t의 **가장 긴 prefix**만 찾아내면 되고, 나머지는 그대로 붙이면 된다.
4. 시간 복잡도는 O(s.length), 공간 복잡도는 O(1)로 매우 효율적이다.
5. 문자열 비교 문제는 **직관적인 포인터 이동 방식**으로 단순화할 수 있다.

## 회고

이번 문제는 단순 문자열 비교 문제지만, “서브시퀀스”의 개념을 다시 복습하게 해줬다.
투 포인터로 s와 t를 비교하면서 t의 어느 부분까지 일치하는지를 찾는 방식이 인상 깊었다.
불필요하게 복잡하게 생각하지 않고, 직관적인 반복문과 조건문으로도 충분히 해결 가능하다는 점에서 자신감을 얻었다.
추후에 더 복잡한 서브시퀀스 문제를 풀 때 기본기처럼 쓸 수 있을 것 같다.
