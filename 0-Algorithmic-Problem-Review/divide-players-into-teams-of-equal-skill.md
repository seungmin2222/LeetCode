## [**Divide Players Into Teams of Equal Skill**](https://leetcode.com/problems/divide-players-into-teams-of-equal-skill/)

이 문제는 주어진 짝수 길이의 배열에서 각 팀의 스킬 합이 같도록 두 명씩 짝을 지어 팀을 구성해야 하며, 모든 팀의 "화학 작용" 합을 반환하되, 불가능할 경우 -1을 반환해야 하는 문제이다.

## 주요 포인트

1. **스킬 합 일치 조건**: 팀을 구성할 때, 모든 팀의 스킬 합이 같아야 한다.
2. **팀의 화학 작용 계산**: 각 팀의 화학 작용은 두 플레이어 스킬의 곱으로 정의된다.
3. **전체 화학 작용 합**: 모든 팀의 화학 작용 값을 더하여 최종 값을 구한다.
4. **불가능한 경우**: 스킬 합이 일정하게 맞춰지지 않는 경우, -1을 반환한다.

## 나의 코드

```jsx
var dividePlayers = function(skill) {
  skill.sort((a,b) => a - b);

  let right = skill.length - 1;
  let left = 0;
  let totalSum = 0;

  const targetSum = skill[left] + skill[right];
  
  while (left < right) {
    const teamSum = skill[left] + skill[right];
    
    if (teamSum !== targetSum) return -1;

    totalSum += skill[left] * skill[right];
    left++;
    right--;
  }

  return totalSum;
};
```

## 나의 수도 코드

1. 주어진 배열 `skill`을 오름차순으로 정렬.
2. 변수 `right`를 배열의 마지막 인덱스로, `left`를 배열의 첫 인덱스로 설정.
변수 `totalSum`은 모든 팀의 합을 저장할 변수로, 0으로 초기화.
3. 배열의 첫 번째와 마지막 요소의 합을 `targetSum`으로 설정.
4. `left`와 `right`가 만나기 전까지 반복.
a. `left`와 `right` 위치의 스킬 합을 `teamSum`으로 설정.
    
    b. `teamSum`이 `targetSum`과 다르면 팀 구성 불가능하므로 -1을 반환.
    
    c. 같다면, 현재 팀의 곱을 `totalSum`에 더함.
    
    d. `left`를 1 증가시키고, `right`를 1 감소시켜 다음 팀을 확인.
    
5. 반복이 끝나면 모든 팀의  곱하기한 합이 저장된 `totalSum`을 반환.

## 시간 복잡도

1. skill.sort((a, b) => a - b)
    - 배열을 오름차순으로 정렬하는 데 걸리는 시간 복잡도는 `O(n log n)`.
    - n은 배열의 길이.
2. while (left < right)
    - 이 while 루프는 left와 right 포인터가 서로 만날 때까지 실행.
    - 즉, 루프의 반복 횟수는 n/2번.
    - 각 반복에서 배열의 첫 번째 원소와 마지막 원소를 비교하고, 그 합이 일정한지를 체크하는 등의 연산이 이루어짐.
    - 이 과정은 `O(1)`의 시간 복잡도.
    - 따라서 while 루프가 수행되는 시간 복잡도는 `O(n)`.
3. 결합된 시간 복잡도
    - 전체적으로 시간 복잡도는 sort와 while 루프에서 각각 `O`
    - `(n log n)`과 `O(n)`이 결합되므로 최종적으로 `O(n log n)`.

## 공간 복잡도

1. 배열 `skill`을 제외한 다른 변수들은 **모두 상수 공간**(O(1))을 사용.
2. `sort()` 메서드는 최악의 경우 `O(log n)`의 추가 공간을 사용할 수 있으며, 이는 배열의 정렬 작업에 필요한 최소 공간.

따라서 이 알고리즘의 **전체 공간 복잡도**는 `O(log n)`.

## 알아둬야 할 것!

1. **정렬을 이용한 양끝 짝짓기**
    - 정렬 후, 양끝에서부터 짝을 지어 스킬 합을 맞추는 방식으로 문제를 해결할 수 있다.
    - 정렬이 된 상태에서 양끝 값의 합이 일정하게 유지될 수 있는지를 체크하는 효율적인 방법이다.
2. **투 포인터 접근법**
    - 배열의 양 끝에서 시작하여 가운데로 점차 이동하는 투 포인터 방식을 사용하여 불필요한 반복을 줄일 수 있다.
    - 특정 조건을 만족하는 쌍을 찾을 때 유용하다.
3. **조건 불일치 시 조기 반환**
    - 조건이 맞지 않는 경우, 반복을 멈추고 즉시 -1을 반환하는 것이 효율적이다.
    - 불필요한 계산을 줄이고 코드의 효율성을 높일 수 있다.

## 회고

이 문제를 통해 정렬과 투 포인터 접근법의 효율성을 느낄 수 있었다.

주어진 조건에 맞춰 팀을 구성하고 일관된 합을 유지하는 것이 중요했으며, 조건이 맞지 않을 때 조기 반환하는 방법이 코드를 효율적으로 만들어야 했다.

또한, 배열 양 끝에서부터 짝을 짓는 방식으로 해결했다.

이를 통해 문제 해결 시 조건을 정확히 이해하고, 효율적인 접근법을 선택하는 것이 얼마나 중요한지 깨달았다.
