## [Number of Sub-arrays With Odd Sum](https://leetcode.com/classic/problems/number-of-sub-arrays-with-odd-sum/description/)

이 문제는 정수 배열이 주어졌을 때, 모든 연속된 부분 배열(subarray)의 합 중에서 홀수인 것의 개수를 구하는 문제이다.

결과값이 매우 클 수 있으므로 10^9 + 7로 나눈 나머지를 반환해야 한다.

## 주요 포인트

- 이 문제는 부분 배열의 합 중 홀수인 것의 개수를 구하는 것으로, 패리티(홀짝성) 특성을 활용해 O(n) 시간으로 풀 수 있다.
- 누적합(prefix sum)과 패리티 관계를 이용해, 현재 인덱스에서의 누적합이 홀수면 이전 짝수 누적합 개수만큼, 짝수면 이전 홀수 누적합 개수만큼 홀수 부분 배열이 생긴다.
- 모듈로(10^9 + 7) 연산을 적용해 큰 숫자 처리 시 오버플로우를 방지해야 한다.

## 나의 코드

```jsx
var numOfSubarrays = function(arr) {
    let count = 0;

    for (let i = 0; i < arr.length; i++) {
        for (let j = i; j < arr.length; j++) {
            let sum = 0;
            for (let k = i; k <= j; k++) {
               sum += arr[k];
            }

            if (sum % 2 === 1) {
              count++;
            }
        }
    }

    return count;
};
```

## 나의 수도 코드

1. 우선 결과를 저장할 카운터 변수를 0으로 초기화.
2. 배열의 모든 요소를 시작점으로 하는 루프를 시작.
3. 각 시작점에서, 해당 위치부터 배열의 끝까지 가능한 모든 끝점을 고려하는 두 번째 루프 실행.
4. 각 시작점과 끝점 쌍에 대해, 해당 범위 내의 모든 요소들을 더하기 위한 세 번째 루프 실행.
5. 이 세 번째 루프에서는 시작점부터 끝점까지 모든 요소를 순회하면서 합계를 계산.
6. 계산된 합이 홀수인지 확인하기 위해 2로 나눈 나머지를 검사.
7. 만약 나머지가 1이라면(즉, 합이 홀수라면) 카운터를 1 증가.
8. 모든 가능한 시작점과 끝점의 조합을 검사한 후, 최종적으로 홀수 합을 가진 부분 배열의 총 개수를 반환.

## 시간 복잡도

- 세 개의 중첩된 루프가 있음
- 첫 번째 루프: O(n)
- 두 번째 루프: 각 i에 대해 O(n-i), 평균적으로 O(n)
- 세 번째 루프: 각 (i, j) 쌍에 대해 O(j-i+1), 평균적으로 O(n)

전체 시간 복잡도는  O(n × n × n) = O(n³)

## 공간 복잡도

- 입력 배열 외에 추가 공간은 단일 변수들(count, sum, 루프 변수)만 사용
- 입력 크기에 관계없이 일정한 양의 추가 메모리만 사용

전체 공간 복잡도는 O(1)

## 다른 사람의 풀이

```jsx
var numOfSubarrays = function(arr) {
    let count = 0;
    let prefixSum = 0;
    
    let even = 1;
    let odd = 0;
    
    const MOD = 1000000007;
    
    const len = arr.length;
    for (let i = 0; i < len; i++) {
        prefixSum += arr[i];
        
        if (prefixSum & 1) {
            count = (count + even) % MOD;
            odd = (odd + 1) % MOD;
        } else {
            count = (count + odd) % MOD;
            even = (even + 1) % MOD;
        }
    }
    
    return count;
};
```

## 알아둬야 할 것!

알고리즘 접근 방식의 차이

1. **나의 코드**: 브루트 포스(완전 탐색) 접근법
    - 모든 가능한 부분 배열을 직접 계산하여 각각의 합이 홀수인지 확인
    - 세 개의 중첩된 루프를 사용하여 모든 부분 배열을 순회
2. **최적화된 코드**: 누적합(Prefix Sum)과 패리티(홀짝성) 특성을 활용한 최적화 접근법
    - 배열을 한 번만 순회하면서 누적합의 패리티를 추적
    - 이전에 나타난 홀수/짝수 누적합의 개수를 이용해 홀수 합을 가진 부분 배열을 계산

## 시간 복잡도

1. **나의 코드**: O(n³)
    - 세 개의 중첩된 루프로 인해 매우 비효율적
2. **최적화된 코드**: O(n)
    - 단일 루프로 최적화되어 훨씬 효율적

## 주요 기술적 차이점

1. **누적합(Prefix Sum) 사용**
    - **나의 코드** : 각 부분 배열마다 합을 처음부터 직접 계산
    - **최적화된 코드** : 누적합을 유지하여 중복 계산 방지
2. **패리티 관계 활용**
    - **나의 코드** : 직접적인 홀수 확인(sum % 2 === 1)
    - **최적화된 코드** : 홀수/짝수 누적합의 관계를 이용(prefixSum & 1)
3. **모듈로 연산**
    - **나의 코드** : 모듈로 연산 없음
    - **최적화된 코드** : 10^9 + 7로 모듈로 연산을 적용하여 큰 숫자 처리
4. **메모리 추적**
    - **나의 코드** : 각 합을 독립적으로 계산
    - **최적화된 코드** : 지금까지 나타난 홀수/짝수 누적합의 개수를 추적(even, odd 변수)

## 결론

**최적화된 코드**는 수학적 통찰력(패리티 특성)을 활용하여 시간 복잡도를 O(n³)에서 O(n)으로 크게 개선했으며, 모듈로 연산을 적용하여 큰 테스트 케이스에서도 정확한 결과를 제공합니다. 이는 알고리즘 최적화의 좋은 예시로, 같은 문제를 해결하는 데 있어 효율성이 크게 향상되었다.

## 회고

이 문제를 통해 브루트 포스 접근법(O(n³))에서 수학적 통찰을 활용한 최적화 접근법(O(n))으로 발전하는 과정을 경험했다.

패리티 특성과 누적합을 활용함으로써 문제 해결의 효율성을 극대화하는 방법을 배웠다. 특히 모듈로 연산의 중요성을 인식하게 되었으며, 이는 큰 숫자를 다룰 때 필수적인 요소임을 확인했다.

이번 경험은 단순히 코드를 작성하는 것을 넘어, 문제의 본질을 파악하고 수학적 패턴을 찾아 효율적인 알고리즘을 설계하는 사고력의 중요성을 일깨워주었다.
