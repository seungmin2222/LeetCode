## [**Final Array State After K Multiplication Operations I**](https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-i/)

이 문제는 `nums` 배열에서 가장 작은 값을 찾아 `multiplier`를 곱한 값으로 대체하는 작업을 `k`번 수행한다.

## 주요 포인트

1. **배열 탐색**
    - 배열을 순회하며 최소값과 해당 인덱스를 찾는 방법을 이해해야 한다.
2. **최소값의 첫 번째 발생 위치 찾기**
    - 동일한 최소값이 여러 번 존재할 때, 첫 번째 발생 위치를 선택하는 조건.
3. **값의 갱신**
    - 찾은 최소값을 특정 연산(곱하기 `multiplier`)을 통해 업데이트하는 방법.
4. **반복문 제어**
    - `k`번의 반복을 통해 최소값을 반복적으로 찾고 수정해야 한다.

## 나의 코드

```jsx
var getFinalState = function(nums, k, multiplier) {
  for (let i = 0; i < k; i++) {
    let minIndex = 0;

    for (let j = 1; j < nums.length; j++) {
      if (nums[j] < nums[minIndex]) {
        minIndex = j;
      }
    }

    nums[minIndex] *= multiplier;
  }

  return nums;
};
```

## 나의 수도 코드

1. **반복문**을 통해 `k`번 반복.
2. **최소값과 인덱스 탐색**
    - `nums` 배열을 순회하며 가장 작은 값을 찾는다.
3. **값 수정**
    - 찾은 최소값을 `x * multiplier`로 대체한다.
4. 최종 배열 반환.

## 시간 복잡도

- 배열을 순회하며 최소값을 찾는 데 **O(n)** 시간이 걸린다.
- **k번 반복:** 최소값 찾기 작업이 `k`번 반복되므로 **O(k * n)**.

최종적으로 시간복잡도는 **O(k * n).**

## 공간 복잡도

최종 공간 복잡도는 별도의 배열이나 구조체를 사용하지 않으므로 **O(1)**.

## 알아둬야 할 것!

1. **배열 탐색 최적화**
    - 최소값을 찾기 위해 배열을 순회하는 과정을 효율적으로 구현하는 방법.
2. **조건에 따른 값 수정**
    - 특정 위치의 값을 조건에 맞게 변경하고 반영하는 방법.
3. **반복 작업 제어**
    - 특정 연산을 `k`번 반복하는 제어 흐름을 명확하게 구현.
4. **시간 복잡도 분석**
    - 작업의 반복 횟수와 배열 길이에 따라 시간 복잡도를 계산하고 최적화 포인트를 확인.

## 회고

이번 문제를 풀면서 배열에서 최소값을 반복적으로 찾고 수정하는 **탐색과 갱신**의 과정을 배웠다.

기본적인 반복문과 조건 제어를 통해 문제를 해결했지만, `O(k * n)`의 시간 복잡도는 큰 입력에 비효율적일 수 있다.

향후 최적화를 위해 우선순위 큐(힙)를 사용하면 최소값을 더 빠르게 찾을 수 있다는 점을 배웠다.

추가 공간을 최소화하면서 반복 작업을 처리하는 능력을 키웠다.
