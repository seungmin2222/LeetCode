## [**Symmetric Tree**](https://leetcode.com/problems/symmetric-tree)

이 문제는 주어진 이진 트리가 자기 자신에 대해 대칭인지 확인하는 문제이다.

즉, 이 트리가 거울을 통해 본 것처럼 좌우가 서로 대칭인지 판별한다.

## 주요 포인트

1. **재귀적 비교**
    - 트리의 왼쪽 서브트리와 오른쪽 서브트리가 거울상 관계에 있는지를 재귀적으로 비교해야 한다.
2. **기저 사례**
    - 두 서브트리가 모두 `null`이면 대칭이고, 하나만 `null`이면 대칭이 아니다.
3. **대칭 조건**
    - 현재 노드 값이 같아야 하며, 왼쪽 서브트리와 오른쪽 서브트리가 대칭이어야 하고,
    - 오른쪽 서브트리와 왼쪽 서브트리가 대칭이어야 한다.
4. **시간 복잡도**
    - 이 알고리즘은 트리의 모든 노드를 한 번씩 방문하므로 시간 복잡도는 O(n)다.

## 나의 코드

```jsx
var isSymmetric = function(root) {
  function isMirror(tree1, tree2) {
      if (!tree1 && !tree2) {
          return true;
      }
      if (!tree1 || !tree2) {
          return false;
      }
      return (tree1.val === tree2.val)
          && isMirror(tree1.right, tree2.left)
          && isMirror(tree1.left, tree2.right);
  }

  if (!root) {
      return true;
  }

  return isMirror(root.left, root.right);
};
```

## 나의 수도 코드

1. **기본 체크**
    - **입력**: 이진 트리의 루트 노드 `root`
    - **작업**: `root`가 `null`인지 확인
    - **출력**
        - `root`가 `null`이면 `true` 반환 (빈 트리는 대칭임)
        - 그렇지 않으면 `isMirror(root.left, root.right)` 호출
2. **재귀 함수 정의 (isMirror)**
    - **입력**: 두 개의 이진 트리 노드 `tree1`과 `tree2`
    - **작업**
        1. **기본 체크**
            - 두 노드가 모두 `null`이면 `true` 반환
            - 한 노드만 `null`이면 `false` 반환
        2. **값 비교**
            - 현재 노드의 값이 서로 같아야 함 (`tree1.val === tree2.val`)
        3. **서브트리 비교**
            - `tree1`의 오른쪽 서브트리와 `tree2`의 왼쪽 서브트리가 대칭인지 확인
            - `tree1`의 왼쪽 서브트리와 `tree2`의 오른쪽 서브트리가 대칭인지 확인
        4. **출력**
            - 모든 조건이 맞으면 `true`, 그렇지 않으면 `false` 반환
3. **함수 호출**
    - **입력**: `root`
    - **작업**
        - `isMirror(root.left, root.right)` 호출하여 결과를 반환
4. **결과 반환**
    - **출력**: `isMirror` 함수의 결과를 반환

## 알아둬야 할 것!

- **재귀 함수의 구조**
    - 재귀를 사용하여 트리의 두 서브트리를 비교할 때, 왼쪽 서브트리와 오른쪽 서브트리를 서로 거울상으로 비교하는 방식을 이해해야 한다.
    - 기저 사례를 정확히 정의하고 처리하는 것이 중요하다. 두 서브트리가 모두 `null`일 때는 대칭으로 간주하고 `true`를 반환한다.
- **대칭 조건**
    - 두 서브트리의 현재 노드 값이 같아야 한다.
    - 왼쪽 서브트리의 오른쪽 자식과 오른쪽 서브트리의 왼쪽 자식이 대칭이어야 하고, 왼쪽 서브트리의 왼쪽 자식과 오른쪽 서브트리의 오른쪽 자식도 대칭이어야 한다.
- **시간 복잡도**
    - 이 알고리즘의 시간 복잡도는 O(n)이다. 이는 트리의 모든 노드를 한 번씩 방문하기 때문이다.
    - 공간 복잡도는 트리의 높이에 따라 O(h)이다. 이는 재귀 호출 스택의 깊이에 영향을 미친다.
- **기본 체크**
    - `null` 노드를 처리하는 로직을 명확히 해야 하며, 이를 통해 대칭 여부를 올바르게 판단할 수 있다.

## 회고

- **재귀의 이해와 활용**
    - 재귀를 사용하여 문제를 해결할 때, 각 호출이 수행하는 작업을 명확히 이해하고, 기저 사례를 올바르게 처리하는 것이 중요하다.
    - `isMirror` 함수는 트리의 두 서브트리가 대칭인지 확인하기 위해 필요한 비교를 수행하며, 재귀 호출로 모든 하위 트리를 비교한다.
- **문제 해결 접근 방식**
    - 문제를 해결하기 위해 트리의 구조와 대칭성 개념을 잘 이해하고, 이를 바탕으로 알고리즘을 설계하는 것이 중요하다.
    - 대칭성 문제는 자주 등장하는 트리 관련 문제로, 재귀를 통한 해결 방법을 익혀두는 것이 유용하다.
- **테스트 케이스의 중요성**
    - 다양한 테스트 케이스를 통해 알고리즘이 모든 경계 조건과 기저 사례를 제대로 처리하는지 확인해야 한다.
    - 예를 들어, 빈 트리, 트리의 모든 노드가 `null`인 경우, 단일 노드로 이루어진 트리 등 다양한 상황을 테스트하는 것이 중요하다.

아직 재귀를 돌리는 것은 편한것이 아니다. 연습이 많이 필요할 것 같다.
