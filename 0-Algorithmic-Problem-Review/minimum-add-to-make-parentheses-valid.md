## [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/)

주어진 괄호 문자열 `s`를 올바른 괄호 문자열로 만들기 위해 최소 몇 개의 괄호를 추가해야 하는지 구하는 문제이다.

## 주요 포인트

1. **올바른 괄호의 정의**
    - 비어 있는 문자열은 올바른 괄호.
    - `(A)` 또는 `AB` 형태로도 올바른 괄호 문자열이 생성될 수 있다.
2. **스택(Stack) 개념**
    - 열린 괄호 `(`와 닫힌 괄호 `)`를 짝지으려면 스택의 동작(Last In First Out, LIFO)과 유사한 원리가 사용된다.
3. **불균형 판단**
    - 열린 괄호의 개수가 많거나 부족한 닫힌 괄호가 있을 경우 이를 보정해야 한다.
4. **최소 추가 계산**
    - 문자열을 왼쪽에서 오른쪽으로 순회하며 남은 열린 괄호의 개수(`open`)와 부족한 닫힌 괄호(`moves`)를 카운트한다.

## 나의 코드

```tsx
var minAddToMakeValid = function(s) {
  let open = 0; 
  let moves = 0;

  for (let char of s) {
    if (char === '(') {
      open++;
    } else if (char === ')') {
      if (open > 0) {
        open--;
      } else {
        moves++;
      }
    }
  }

  return moves + open;
};
```

## 나의 수도 코드

1. **변수 초기화**
    - `open = 0` (현재 짝이 맞지 않은 열린 괄호 수)
    - `moves = 0` (부족한 닫힌 괄호 수)
2. **문자열 순회**
    - `for char in s`
        - **(a)** `char == '('`이면 `open` 증가 (`open += 1`)
        - **(b)** `char == ')'`이면
            - `open > 0`이면 `open` 감소 (`open -= 1`)
            - 아니면 `moves` 증가 (`moves += 1`)
3. **결과 반환**
    - `return moves + open`(남은 열린 괄호와 부족한 닫힌 괄호의 합)

## 시간 복잡도

- 문자열 `s`를 한 번 순회하며 처리하므로 **O(n)**

## 공간 복잡도

- 추가적으로 사용하는 변수는 `open`과 `moves` 두 개의 정수형 변수로, 고정된 공간만 사용된다.
- 따라서 **O(1)**.

## 알아둬야 할 것!

1. **올바른 괄호 문자열의 불균형 해결**
    - 열린 괄호는 남은 개수(`open`)로 추적하고, 부족한 닫힌 괄호는 추가 움직임(`moves`)으로 계산한다.
    - 최종적으로 `open`과 `moves`를 더하면 최소 추가 개수를 알 수 있다.
2. **최소 추가의 의미**
    - 부족한 닫힌 괄호는 즉시 보정(`moves++`)하고, 남은 열린 괄호는 마지막에 모두 보정(`open`).
3. **문자열 한 번 순회로 해결 가능**
    - 문자열 전체를 한 번 순회하며 `O(n)` 시간 내에 처리할 수 있는 효율적인 방법.

## 회고

이번 문제를 통해 괄호 문자열의 유효성을 판단하고 최소 추가로 수정하는 방법을 익혔다.

스택 대신 카운터(`open`, `moves`)만으로 효율적으로 해결하여 시간 복잡도 O(n), 공간 복잡도 O(1)의 풀이를 구현한 점이 만족스럽다.

예외 처리와 테스트 케이스를 통해 코드의 정확성을 높였으며, 효율성과 단순성의 중요성을 깨달았다.

앞으로도 다양한 문제에서 간결한 접근 방식을 우선적으로 고려해야겠다.
