# [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)

이 문제에서는 주어진 그리드에서 썩은 오렌지가 4방향 인접한 신선한 오렌지를 매 분마다 썩게 할 때, 모든 신선한 오렌지가 썩는 데 걸리는 최소 시간을 구하는 문제이다. 불가능할 경우 -1을 반환합니다.

## 주요 포인트

1. **그리드 상태**: 각 셀은 빈 셀(0), 신선한 오렌지(1), 썩은 오렌지(2)로 표시됨.
2. **4방향 전파**: 썩은 오렌지가 매 분마다 상하좌우 인접한 신선한 오렌지를 썩게 함.
3. **결과 판단**: 모든 오렌지가 썩었다면 걸린 시간을 반환, 신선한 오렌지가 남아있으면 -1 반환.

## 나의 코드

```jsx
var orangesRotting = function(grid) {
  let count = 0;
  let hasFresh = true;

  const directions = [
    [-1, 0], [1, 0], [0, -1], [0, 1]
  ];

  while (hasFresh) {
    hasFresh = false;
    let newGrid = JSON.parse(JSON.stringify(grid));
    
    for (let i = 0; i < grid.length; i++) {
      for (let j = 0; j < grid[i].length; j++) {
        if (grid[i][j] === 2) {
          for (let [dx, dy] of directions) {
            let newX = i + dx;
            let newY = j + dy;

            if (
              newX >= 0 && newX < grid.length &&
              newY >= 0 && newY < grid[0].length &&
              grid[newX][newY] === 1
            ) {
              newGrid[newX][newY] = 2;
              hasFresh = true; 
            }
          }
        }
      }
    }

    if (hasFresh) {
      count++; 
      grid = newGrid;  
    }
  }

  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
      if (grid[i][j] === 1) {
        return -1;  
      }
    }
  }

  return count;  
};
```

## 나의 수도 코드

1. 변수 초기화
    - `count = 0`: 썩는 데 걸린 분을 세는 변수
    - `hasFresh = true`: 신선한 오렌지가 남아 있는지 확인하는 플래그
    - `directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]`: 상, 하, 좌, 우 네 방향을 나타내는 배열
2. 반복문 시작: 신선한 오렌지가 남아 있을 때까지 반복
    - `hasFresh = false`: 새로운 썩은 오렌지가 생기는지 확인하기 위해 매 반복마다 초기화
    - `newGrid = grid의 깊은 복사본`: 새롭게 업데이트될 그리드
3. 2중 반복문으로 모든 셀을 탐색
    - 만약 셀이 썩은 오렌지(값이 2)라면:
        - 네 방향(상, 하, 좌, 우)을 확인
            - 새로운 좌표(`newX, newY`)가 유효한 범위 내에 있고, 신선한 오렌지(값이 1)라면:
                - 해당 좌표의 셀을 썩은 오렌지(값을 2로 변경)로 바꾸고, `hasFresh = true`로 설정 (썩는 오렌지가 있음을 의미)
4. 만약 신선한 오렌지가 썩었다면
    - `count`를 1 증가
    - `grid`를 `newGrid`로 업데이트
5. 반복이 끝난 후, 그리드를 다시 확인
    - 여전히 신선한 오렌지(값이 1)가 남아있으면 -1을 반환 (썩을 수 없는 오렌지가 남아있음을 의미)
    - 그렇지 않다면 `count`를 반환 (모든 오렌지가 썩는 데 걸린 분)
6. 프로그램 종료

## 다른 사람의 풀이

```jsx
var orangesRotting = function(grid) {
  let rows = grid.length;
  let cols = grid[0].length;
  let queue = [];
  let freshCount = 0;
  let minutes = 0;

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (grid[i][j] === 2) {
        queue.push([i, j]);
      } else if (grid[i][j] === 1) {
        freshCount++;
      }
    }
  }

  const directions = [
    [-1, 0], [1, 0], [0, -1], [0, 1]
  ];

  while (queue.length > 0 && freshCount > 0) {
    let newQueue = [];
    while (queue.length > 0) {
      let [x, y] = queue.shift();

      for (let [dx, dy] of directions) {
        let newX = x + dx;
        let newY = y + dy;

        if (
          newX >= 0 && newX < rows &&
          newY >= 0 && newY < cols &&
          grid[newX][newY] === 1
        ) {
          grid[newX][newY] = 2;
          newQueue.push([newX, newY]);
          freshCount--;
        }
      }
    }
    queue = newQueue;
    minutes++;
  }

  return freshCount === 0 ? minutes : -1;
};

```

1. 변수 초기화
    - `rows = grid.length`, `cols = grid[0].length`: 그리드의 행과 열 크기 저장
    - `queue = []`: 썩은 오렌지들의 좌표를 저장할 큐
    - `freshCount = 0`: 신선한 오렌지 개수 저장
    - `minutes = 0`: 경과 시간 저장
2. 초기 상태 설정
    - 2중 반복문으로 그리드의 모든 셀을 탐색
    - 셀이 썩은 오렌지(값이 2)면 큐에 추가
    - 셀이 신선한 오렌지(값이 1)면 신선한 오렌지 개수 증가
3. 네 방향 배열 설정
    - `directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]`: 상, 하, 좌, 우 네 방향 설정
4. BFS 탐색 시작
    - 큐에서 썩은 오렌지의 좌표를 하나씩 꺼내어 네 방향으로 신선한 오렌지가 있는지 확인
    - 신선한 오렌지가 있으면 썩은 오렌지로 바꾸고, 새로운 썩은 오렌지를 큐에 추가
    - 매 반복마다 `minutes` 값을 증가
5. BFS 종료 후 결과 판단
    - 신선한 오렌지(`freshCount`)가 남아있지 않으면 `minutes` 반환
    - 남아 있으면 -1 반환

## 회고

### **1. 최초 코드**

- **방식**: 각 반복마다 그리드 전체를 탐색하면서 신선한 오렌지가 썩는 과정을 시뮬레이션한다.
- **시간 복잡도**: 이중 반복문을 사용하여 그리드를 매번 완전히 탐색한 후, 썩은 오렌지를 확인하고 그 다음에도 계속 그리드를 반복 탐색한다.
    - 그리드의 크기를 `m x n`이라고 하면, 매번 그리드를 탐색할 때마다 `O(m * n)`의 시간이 걸린다.
    - 신선한 오렌지가 남아있는 동안, 그리드를 계속해서 반복 탐색하므로 최악의 경우 그리드의 모든 오렌지가 하나씩 썩는다면 총 시간 복잡도는 `O((m * n) * (m * n))`, 즉 O((m * n)^2)가 된다.

### 2. **최적화된 코드 (BFS 방식)**

- **방식**: 썩은 오렌지들만 큐에 저장하고, BFS 방식으로 한 번에 썩은 오렌지들을 퍼뜨린다. 즉, 한 번의 탐색에서 신선한 오렌지를 모두 퍼뜨릴 수 있도록 최적화했다.
- **시간 복잡도**
    - BFS 방식으로 썩은 오렌지를 탐색하면서 신선한 오렌지를 찾는다.
    - 매 탐색에서 신선한 오렌지들만 처리하기 때문에 그리드를 전체적으로 완전히 탐색하지 않고, 오렌지들이 있는 부분만 확인한다.
        - 큐에 추가되는 썩은 오렌지는 최대 `m * n`번 탐색할 수 있다.
        - 각 오렌지에 대해 4방향을 탐색하므로 시간 복잡도는 O(m * n)이다.

### 3. **차이점 요약**

- **비효율적인 첫 코드**는 신선한 오렌지가 썩을 때마다 그리드 전체를 다시 탐색해야 하기 때문에 매우 비효율적이며 시간 복잡도가 O((m * n)^2)가 된다.
- **최적화된 코드**는 BFS를 사용하여 한 번에 모든 썩은 오렌지가 퍼지는 과정을 처리하므로 시간 복잡도가 **O(m * n)**으로 훨씬 효율적이다.

### 4. **최적화의 효과**

- **첫 코드**는 작은 그리드에서는 작동할 수 있지만, 그리드가 커질수록 연산 시간이 급격히 증가한다.
- **최적화된 코드**는 BFS 방식을 사용하여 한 번에 여러 오렌지가 썩게 하므로 훨씬 더 빠르게 동작하며, 특히 큰 그리드에서 큰 성능 향상을 볼 수 있다.

최적화의 핵심은 불필요한 중복 연산을 줄이고 필요한 부분만 효율적으로 탐색하는 데 있다. BFS 방식은 이 문제에서 최선의 선택이 된다.


## BFS의 주요 특징

1. **레벨별 탐색**
    - BFS는 특정 지점(노드 또는 셀)에서 시작하여 그 지점과 인접한 모든 지점을 먼저 탐색한 후, 그 다음 레벨로 넘어간다.
    - 이 문제에서는 **썩은 오렌지들**을 중심으로 시작하여, 그들과 인접한 신선한 오렌지들을 한 번에 처리하는 방식으로 확산한다.
    - 즉, 매 반복마다 **1분** 동안 모든 썩은 오렌지가 동시에 신선한 오렌지를 썩게 한다.
2. **큐(queue) 자료구조 사용**
    - BFS는 FIFO(First In, First Out) 방식의 **큐** 자료구조를 사용한다. 
    먼저 탐색된 노드가 먼저 처리되기 때문에, 썩은 오렌지를 발견한 후 바로 인접한 신선한 오렌지를 처리할 수 있다.
    - 이 문제에서 처음에 썩은 오렌지들을 큐에 넣고, 그 오렌지들이 4방향으로 신선한 오렌지를 썩게 한 후, 새롭게 썩은 오렌지를 다시 큐에 넣어 반복한다.
3. **최단 거리 탐색**
    - BFS는 시작점으로부터 목표 지점까지의 최단 거리를 탐색하는 데 적합한 알고리즘이다.
    - 이 문제에서는 **썩은 오렌지가 신선한 오렌지를 썩게 만드는 최소 시간을 구하는 문제**이므로, BFS는 한 번의 탐색으로 모든 오렌지가 썩을 수 있는 최단 시간을 계산하는 데 매우 적합하다.
    - 각 레벨(큐에서 꺼낸 요소의 개수)은 시간이 지나며 썩는 오렌지의 확산을 의미한다.
4. **동시에 여러 지점에서 퍼짐**
    - BFS는 동시에 여러 노드에서 탐색을 시작할 수 있다. 이 문제에서는 여러 썩은 오렌지가 존재할 수 있는데, 각 썩은 오렌지가 동시에 인접한 신선한 오렌지를 썩게 만든다. 이 과정을 **큐에서 한 번에 처리**하기 때문에 효율적이다.

### BFS의 원리

1. **초기 상태**
    - 썩은 오렌지들의 좌표를 모두 큐에 넣고, 신선한 오렌지의 개수를 센다.
    - 썩은 오렌지들에서 동시에 BFS 탐색을 시작한다.
2. **탐색 과정**
    - 큐에서 썩은 오렌지 하나를 꺼내어 4방향(상, 하, 좌, 우)에 신선한 오렌지가 있는지 확인한다.
    - 신선한 오렌지가 있으면 해당 오렌지를 썩은 오렌지로 바꾸고, 그 좌표를 큐에 넣는다.
    - 이 과정을 통해 한 번의 반복이 끝날 때마다 인접한 신선한 오렌지가 모두 썩게 되고, 이 과정이 끝나면 1분이 지나게 된다.
3. **종료 조건**
    - 모든 신선한 오렌지가 썩었을 때 종료하거나, 더 이상 썩을 수 있는 신선한 오렌지가 남아 있지 않으면 종료한다.
    - 신선한 오렌지가 남아있으면 -1을 반환하고, 모두 썩었다면 걸린 시간을 반환한다.

### BFS가 적합한 이유

- 이 문제에서는 썩은 오렌지들이 동시에 확산되는 것을 처리해야 하는데, BFS는 한 번의 탐색으로 여러 방향으로 동시에 퍼지는 문제에 적합하다.
- BFS는 각 레벨이 하나의 시간 단위를 나타내기 때문에, 신선한 오렌지가 썩는 데 걸리는 최소 시간을 계산하기에 적합한 알고리즘이다.
- BFS는 불필요한 중복 탐색을 피하고, 오렌지의 상태만 변경할 수 있는 경우에만 탐색을 수행하므로 효율적으로 문제를 해결할 수 있다.
