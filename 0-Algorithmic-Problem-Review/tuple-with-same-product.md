## [**Tuple with Same Product**](https://leetcode.com/classic/problems/tuple-with-same-product/description/)

이 문제는 두 개의 곱셈이 같은 쌍을 찾는 문제입니다. 주어진 배열에서 `a * b = c * d`를 만족하는 모든 튜플 `(a, b, c, d)`를 찾아야 한다.

`a`, `b`, `c`, `d`는 모두 배열의 원소여야 하며, 중복 없이 서로 다른 값이어야 한다.

## 주요 포인트

1. 각 쌍 `(a, b)`에 대해 `a * b`의 값을 계산하고, 그 값을 키로 사용하여 해시맵에 저장한.
2. 그 후, 동일한 곱셈 결과를 가진 다른 쌍 `(c, d)`를 찾는다.
3. `(a, b)`와 `(c, d)`가 같은 곱셈 값을 가지면, 그 두 쌍은 유효한 튜플을 형성한다. 하지만 `a, b, c, d`가 서로 다른 값이어야 하므로 이 점을 체크해야 한다.

## 나의 코드

```jsx
var tupleSameProduct = function(nums) {
    let count = 0;
    let productMap = new Map();
    
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            let product = nums[i] * nums[j];

            if (productMap.has(product)) {
                count += productMap.get(product);
            }

            productMap.set(product, (productMap.get(product) || 0) + 1);
        }
    }
    
    return count * 8;
};
```

## 나의 수도 코드

1. `i`와 `j`를 사용하여 모든 `(a, b)` 쌍을 계산.
2. `nums[i] * nums[j]`를 계산하여 그 값을 `productMap`에 저장.
3. 이 맵은 곱셈 결과(`product`)를 키로 하고, 그 결과가 나온 횟수를 값으로 저장.
    1. 동일한 곱셈 결과를 가진 튜플들이 반복되기 때문에, `productMap`에서 이전에 나온 곱셈 결과를 조회하여 튜플 수를 계산.
4. 곱셈 결과가 동일한 쌍이 발견되면, 그 쌍을 튜플로 만듬.
5. 따라서 각 쌍에 대해 8개의 튜플이 가능하므로 결과에 8을 곱함.

## 시간 복잡도

1. 중첩된 루프 → `O(n^2)`
2. 곱셈 결과와 Map 업데이트 → `O(1)` 

최종적으로 시간 복잡도는 `O(n^2)` 이다.

## 공간 복잡도

1. productMap는 최대 `n * (n - 1) / 2`개의 고유한 곱셈 결과가 나올 수 있다.
    
    → `O(n^2)`
    
2.  외의 변수들은 상수이다.

따라서 **전체 공간 복잡도**는 `O(n^2)`이다.

## 알아둬야 할 것!

1. **중첩 루프**
    - 두 개의 루프를 사용하여 배열의 모든 쌍을 확인하는 방법.
    - 이 문제에서는 `(a, b)`와 `(c, d)` 쌍을 구하기 위해 중첩된 루프를 사용했다.
2. **해시맵 (Map)**
    - 곱셈 결과를 저장하고, 같은 결과를 가진 다른 쌍을 빠르게 찾아내는 데 사용된다.
    - `Map`은 평균적으로 `O(1)` 시간에 삽입과 조회가 가능하다.
3. **조합 (Combination)**
    - 배열에서 쌍을 고르는 방식에 대해 이해할 필요가 있다.
    - 문제에서는 두 개의 다른 값이 곱해지는 경우를 찾아야 하므로, 중복을 피하는 방법을 고려해야 한다.

## 회고

이 문제를 풀면서 중첩된 루프를 사용하여 모든 쌍을 확인하는 과정이 핵심이었고, 이를 효율적으로 처리하기 위해 해시맵을 활용했다.

해시맵을 사용하여 곱셈 결과를 빠르게 찾을 수 있다는 점에서 효율성을 크게 개선할 수 있었다.

시간 복잡도와 공간 복잡도를 계산하는 부분에서 좀 더 신경을 써야 한다는 점을 배웠다.

향후 비슷한 문제를 풀 때도 해시맵을 적절히 활용할 수 있을 것 같다.
