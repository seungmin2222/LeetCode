## [Length of Longest Fibonacci Subsequence](https://leetcode.com/classic/problems/length-of-longest-fibonacci-subsequence/description/)

이 문제는 "가장 긴 피보나치 부분 수열"을 찾는 문제이다.

주어진 배열에서 피보나치 수열처럼 각 항이 바로 앞의 두 항의 합과 같은 부분 수열 중 가장 긴 것의 길이를 반환해야 한다.

## 주요 포인트

1. 피보나치 부분 수열은 최소 3개의 숫자가 필요하다.
2. 가능한 모든 시작점 쌍(첫 두 숫자)을 고려하여 피보나치 수열을 만들어 보고, 그 중 가장 긴 수열의 길이를 찾아야 한다.
3. 동적 프로그래밍을 활용하면 효율적으로 이 문제를 해결할 수 있다.

## 나의 코드

```jsx
var lenLongestFibSubseq = function(arr) {
    const n = arr.length;
    
    const indexMap = new Map();
    for (let i = 0; i < n; i++) {
        indexMap.set(arr[i], i);
    }
    
    const dp = Array(n).fill().map(() => Array(n).fill(0));
    
    let maxLength = 0;
    
    for (let j = 0; j < n; j++) {
        for (let i = 0; i < j; i++) {
            const next = arr[i] + arr[j];
            
            if (indexMap.has(next)) {
                const k = indexMap.get(next);

                dp[j][k] = dp[i][j] > 0 ? dp[i][j] + 1 : 3;
                maxLength = Math.max(maxLength, dp[j][k]);
            }
        }
    }
    
    return maxLength;
};
```

## 나의 수도 코드

1. 값-인덱스 매핑 구성
    - 먼저 배열의 각 값과 해당 인덱스를 매핑하는 Map을 만듬.
2. DP 배열 초기화
    - `dp[i][j]`는 `arr[i]`와 `arr[j]`로 끝나는 피보나치 부분 수열의 길이를 저장.
3. 모든 가능한 쌍 검사
    - 이중 루프를 통해 배열의 모든 가능한 쌍(i, j)에 대해 다음 피보나치 수(arr[i] + arr[j])가 배열에 존재하는지 확인.
4. DP 상태 업데이트
    - 다음 수가 존재한다면
        - 이미 진행 중인 수열이면 dp[j][k]를 dp[i][j] + 1로 업데이트.
        - 새로운 시작점이면 dp[j][k]를 3으로 설정(i, j, k의 3개 원소).
5. 최대 길이 갱신
    - 각 단계마다 최대 길이를 갱신.

## 시간 복잡도

1. 이중 반복문
    - 코드에서 두 개의 중첩된 for 루프가 있으며, 각각 n번 실행.
2. 맵 구성
    - 배열의 모든 요소를 Map에 저장하는 데 O(n) 시간이 소요.

전체적인 시간복잡도는 모든 가능한 두 개의 숫자 쌍에 대해 연산을 수행하므로 O(n²)이다.

## 공간 복잡도

1. DP 배열
    - n x n 크기의 2차원 배열을 사용합니다. 이 배열은 O(n²) 공간을 차지합니다.
2. 인덱스 맵
    - 모든 배열 요소를 저장하는 Map은 O(n) 공간을 사용합니다.

전체적인 공간복잡도는 DP 배열이 지배적이므로 O(n²)이다.

## 알아둬야 할 것!

1. 부분 수열의 정의
    - 원래 배열에서 요소를 건너뛸 수 있지만 상대적 순서는 유지하는 수열
2. DP 상태 설계
    - `dp[i][j]`는 `arr[i]`와 `arr[j]`로 끝나는 피보나치 부분 수열의 길이를 저장
3. 효율적인 탐색
    - 해시맵(Map)을 사용해 값에서 인덱스로의 O(1) 조회로 다음 피보나치 수를 빠르게 찾음
4. DP 상태 전이
    - 새 시작점은 길이 3으로, 기존 시퀀스는 `dp[i][j] + 1`로 업데이트하여 중복 계산 방지

## 회고

이 문제는 모든 가능한 시작점 쌍을 고려하면서도 효율적인 해결책이 필요했다.

DP 상태를 `dp[i][j]`로 정의하여 "arr[i]와 arr[j]로 끝나는 피보나치 수열의 길이"를 저장하는 접근법이 효과적이었다.

해시맵을 활용해 O(1) 시간에 다음 피보나치 수를 찾고, 새로운 시작점과 기존 시퀀스를 구분하는 로직이 핵심이었다.

O(n²)의 시간/공간 복잡도로 모든 가능한 부분 수열을 고려할 수 있었으며, 이 패턴은 다른 부분 수열 문제에도 적용 가능하다.
