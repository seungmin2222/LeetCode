## [**Count Number of Maximum Bitwise-OR Subsets**](https://leetcode.com/classic/problems/count-number-of-maximum-bitwise-or-subsets/description/)

이 문제는 정수 배열에서 모든 부분집합의 비트 OR 값을 계산하여 **최대 비트 OR 값**을 가지는 부분집합의 개수를 구하는 문제이다.

## 주요 포인트

- 각 부분집합에 대해 요소들의 비트 OR 값을 계산한다.
- 계산된 OR 값 중 가장 큰 값을 추적하며, 해당 최대 OR 값을 가지는 부분집합의 개수를 카운트한다.

## 풀이

```jsx
var countMaxOrSubsets = function(nums) {
    let maxOr = 0; 
    let count = 0; 

    const n = nums.length;
    const totalSubsets = 1 << n;

    for (let mask = 0; mask < totalSubsets; mask++) {
        let currentOr = 0;
        for (let i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                currentOr |= nums[i];
            }
        }

        if (currentOr > maxOr) {
            maxOr = currentOr;
            count = 1;
        } else if (currentOr === maxOr) {
            count++;
        }
    }

    return count;
};
```

1. 수도 코드
2. `maxOr`를 0으로 설정.
3. `count`를 0으로 설정.
4. 총 부분집합의 개수는 `2^n`이므로, 0부터 `2^n - 1`까지의 모든 `mask`를 순회.
5. 각 `mask`를 순회하며, 비트가 켜진(`1`) 위치에 해당하는 요소를 부분집합에 포함.
6. 포함된 요소들의 비트 OR 값을 계산.
7. 현재 OR 값이 `maxOr`보다 크면
    - `maxOr`를 갱신.
    - `count`를 1로 초기화.
8. 현재 OR 값이 `maxOr`와 같으면 `count`를 1 증가.
9. 최대 OR 값을 가진 부분집합의 개수 `count`를 반환.

## 시간 복잡도

1. **부분집합 탐색**
    - 총 `2^n`개의 부분집합을 생성해야 함.
2. **OR 연산**
    - 각 부분집합에 대해 최대 `n`번의 OR 연산을 수행.

**최종 시간 복잡도는** O(n⋅2^n), 여기서 n은 배열의 길이.

## 공간 복잡도

1. **추가 메모리 사용**
    - `maxOr`와 `count` 변수는 상수 공간 사용 → O(1).
    - 비트마스킹은 추가 메모리를 사용하지 않음.

**총 공간 복잡도는** O(1), 입력 배열 외 추가 메모리 사용 없음.

## 알아둬야 할 것!

- 비트마스킹을 활용해 배열의 모든 부분집합을 효율적으로 생성할 수 있다.
    
    > 비트마스킹을 간단하게 설명하면, 숫자의 이진수 표현을 활용해 배열에서 **특정 요소를 선택하거나 제외**하는 방식이다. 문제를 해결하는 데 사용하는 방식은 생각보다 간단하다.
    > 
    
    > 비트마스킹을 사용하는 이유
    > 
    > 
    > > 배열의 모든 부분집합을 효율적으로 표현하려는 방법이다.
    > 예를 들어, 배열의 각 요소를 **포함할지 안 할지**를 `0`과 `1`로 표현하는 거라고 생각하면 된다.
    > > 
    
- 부분집합의 개수는 2n개로, 각 부분집합의 OR 값을 계산하는 데 O(n)의 시간이 걸린다.
- 최대 OR 값이 갱신될 때마다 해당 값을 가진 부분집합 개수를 초기화하거나 증가시킨다.
- 비트 연산은 상수 시간 복잡도를 가지며, OR 연산을 반복적으로 수행해도 효율적이다.
- 이 과정을 통해 모든 부분집합을 탐색하면서 최적의 결과를 도출할 수 있다.

## 회고

이번 문제를 통해 **비트마스킹**을 활용한 부분집합 탐색과 **비트 OR 연산**의 개념을 배울 수 있었다.

배열의 모든 부분집합을 생성하고 각 부분집합의 OR 값을 계산하며, 최대 OR 값을 추적하고 카운트하는 과정을 경험했다.

O(n⋅2^n)의 시간 복잡도로 문제를 해결했으며, 비트 연산의 효율성과 활용 가능성을 느낄 수 있었다. 또한, 비트마스킹은 부분집합 문제뿐 아니라 최적화 문제에서도 활용될 수 있다는 점을 깨달았다. 앞으로도 이런 효율적인 기법을 다양한 문제에 응용할 수 있도록 연습을 지속해야겠다.
