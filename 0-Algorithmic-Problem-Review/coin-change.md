## [Coin Change](https://leetcode.com/problems/coin-change/)

이 문제는 동전의 종류와 총 금액이 주어질 때, 총 금액을 만들기 위해 필요한 최소 동전 개수를 구하는 문제이다.

## 나의 코드

```jsx
var coinChange = function(coins, amount) {
  const dp = new Array(amount + 1).fill(Infinity);
  dp[0] = 0;

  for (const coin of coins) {
    for (let i = coin; i <= amount; i++) {
      if (dp[i - coin] !== Infinity) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp[amount] === Infinity ? -1 : dp[amount];
};
```

## 나의 수도 코드

1. 배열 dp를 길이 amount + 1로 생성하고 모든 값을 Infinity로 초기화
2. dp[0]을 0으로 설정
3. 각 동전 coin에 대해 다음을 수행
4. 금액을 동전으로부터 amount 까지 반복
    1. 만약 dp[i - coin]이 Infinity가 아니면 (즉, 금액 i - coin을 만들 수 있으면)
    2. dp[i]를 dp[i - coin] + 1과 dp[i] 중 최소 값으로 업데이트
5. dp[amount]가 Infinity인 경우, -1을 반환
6. 렇지 않으면, dp[amount]의 값을 반환

## 알아둬야 할 것!

**동적 프로그래밍 (DP)**

- 문제를 부분 문제로 나누어 해결하고, 부분 문제의 결과를 저장하여 중복 계산을 피하는 방법이다.
- 이 문제에서는 금액을 만들기 위한 최소 동전 개수를 구하는 데 사용되는데 잘 알아둬야 할 것 같다.

## DP 배열 (Dynamic Programming Array)이란?

DP, 즉 다이나믹 프로그래밍(또는 동적 계획법)은 복잡한 문제를 더 작은 하위 문제로 나누어 해결하는 **알고리즘 설계 기법이다.**

### DP 문제 해결 방식은 크게 두가지가 있다.

1. **Bottom-Up** (Tabulation 방식) - 반복문 사용
    
    Bottom-Up 방식은 작은 부분 문제부터 차례대로 해결하여 전체 문제를 해결하는 방식이다.
    이를 위해 반복문을 사용하여 반복적으로 부분 문제들을 해결하고, 결과를 배열 등에 저장한다..
    
    > 👍 일반적으로 더 직관적이고 이해하기 쉽습니다. 또한, 모든 작은 부분 문제를 해결하므로 최적 부분 구조를 보장한다.
    > 
2. **Top-Down** (Memoization 방식) - 재귀 사용
    
    큰 문제를 작은 부분 문제로 나누어 해결하는 방식이다.
    
    이를 위해 재귀 함수를 사용하여 문제를 작은 부분 문제들로 쪼개고, 중복 계산을 피하기 위해
    이전에 계산한 값을 저장하는 Memoization을 활용한다.
    
    Memoization은 캐싱을 통해 이전 계산 결과를 저장하여 중복 계산을 피하는 것을 의미한다.
    
    > 👍 Memoization은 재귀를 사용하므로 구현이 더 간단할 수 있다. 또한, 필요한 부분 문제만 해결하므로 계산 시간을 절약할 수 있다.
    하지만 재귀 호출의 오버헤드가 발생할 수 있으며, 모든 작은 부분 문제를 해결하지 않을 경우 최적 부분 구조를 보장하지 않을 수 있다.
    > 

## 회고

- **DP 배열의 중요성**
    - DP 배열을 사용하여 중복 계산을 피하고 효율적으로 문제를 해결한다.
    - 배열 초기화와 업데이트가 정확해야만 올바른 결과를 도출할 수 있다.
- **동전 업데이트 로직**
    - 각 동전을 사용하여 가능한 금액을 업데이트하는 로직이 중요하다고 느꼈다.
    - 동전 종류와 금액을 효율적으로 고려하면서 DP 배열을 업데이트한다.
- **결과 확인**
    - dp[amount]가 Infinity일 경우를 처리하여 금액을 만들 수 없는 경우를 정확히 확인해야 한다.
    - 이 처리 과정이 문제를 올바르게 해결하는 데 필수!!!
- **디버깅 및 테스트**
    - 다양한 입력 값을 사용해 DP 배열이 올바르게 업데이트되는지 확인한다.
    - 간단한 예제부터 복잡한 예제까지 모두 테스트하여 알고리즘의 정확성을 검증한다.
