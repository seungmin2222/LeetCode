## [**Search in Rotated Sorted Array**](https://leetcode.com/problems/search-in-rotated-sorted-array)

이 문제는 주어진 회전된 정렬 배열에서 목표 값 `target`의 인덱스를 **O(log n)** 시간 복잡도로 찾는것이다.
 배열은 한 번 회전된 상태이므로, 이진 탐색을 변형하여 해결해야 한다.

## 주요 포인트

1. 배열은 한 번 회전되었고, 일부 구간만 정렬된 상태이다.
2. 이진 탐색을 적용하여 배열의 중간 값을 기준으로 탐색 범위를 좁혀 나간다.
3. **왼쪽 구간이 정렬된 경우**: `nums[left] <= nums[mid]` 조건으로 판단.
4. 정렬된 구간에 `target`이 있는지 확인하여 탐색 범위를 조정함.
5. 목표 값이 없으면 -1을 반환, 탐색 시간 복잡도는 **O(log n)**.

## 나의 코드

```jsx
var search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        
        if (nums[mid] === target) {
            return mid;
        }

        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
};
```

## 나의 수도 코드

1. **초기화**
    - 왼쪽 포인터 `left`를 0으로, 오른쪽 포인터 `right`를 배열의 마지막 인덱스로 설정.
2. **반복문 시작**
    - `left`가 `right`보다 작거나 같은 동안 반복.
3. **중간 인덱스 계산**
    - `mid` = (left + right) // 2 (중간 인덱스를 계산).
4. **중간 값과 타겟 비교**
    - `nums[mid]`가 `target`과 같으면, `mid`를 반환.
5. **왼쪽 구간 확인**
    - 만약 `nums[left]`가 `nums[mid]`보다 작거나 같으면, 왼쪽 구간이 정렬된 상태.
    - `target`이 이 정렬된 왼쪽 구간에 속하는지 확인:
        - 만약 `target`이 `nums[left]`와 `nums[mid]` 사이에 있으면, 오른쪽 범위를 좁힘 (`right = mid - 1`).
        - 그렇지 않으면, 왼쪽 범위를 좁힘 (`left = mid + 1`).
6. **오른쪽 구간 확인**
    - 만약 왼쪽 구간이 정렬되지 않았다면, 오른쪽 구간이 정렬된 상태.
    - `target`이 이 정렬된 오른쪽 구간에 속하는지 확인:
        - 만약 `target`이 `nums[mid]`와 `nums[right]` 사이에 있으면, 왼쪽 범위를 좁힘 (`left = mid + 1`).
        - 그렇지 않으면, 오른쪽 범위를 좁힘 (`right = mid - 1`).
7. **타겟이 없을 때**
    - 반복문이 끝난 후에도 `target`을 찾지 못하면 -1을 반환.

## 알아둬야 할 것!

- **이진 탐색의 기본 원리**
    - 이 문제는 이진 탐색을 변형하여 푸는 문제이므로, 이진 탐색이 어떻게 동작하는지 이해해야 한다.
- **회전된 배열의 특성**
    - 배열이 한 번 회전되었을 때, 일부 구간은 여전히 정렬되어 있다는 점을 알아야 한다.
    - 이를 이용해 탐색 범위를 조정할 수 있다.
- **조건에 따른 분기 처리**
    - `nums[left] <= nums[mid]` 같은 조건을 통해 어느 구간이 정렬되어 있는지 파악하고,
    정렬된 구간에 `target`이 있는지 여부에 따라 검색 범위를 좁혀나가는 로직을 이해해야 한다.
- **시간 복잡도 O(log n)**
    - 문제에서 요구하는 성능을 만족시키기 위해서는 O(log n) 복잡도를 갖는 이진 탐색 알고리즘을 사용해야 함을 명확히 알아야 한다.

## 회고

- 문제를 처음 봤을 때 복잡해 보였지만 알고리즘의 핵심은 배열의 특성을 파악하고, 이를 활용한 이진 탐색이라는 것을 깨닫고 나니 문제의 구조가 명확해졌다. 회전된 배열에서 구간별로 정렬된 부분이 있다는 점이 핵심이었다.
- 왼쪽과 오른쪽 구간의 정렬 여부를 이용한 탐색
    - 회전된 배열을 다루면서 정렬된 구간을 찾아내는 것이 중요했고, 이를 통해 탐색 범위를 빠르게 좁혀 나갈 수 있었다.
- 조건 분기의 중요성
    - 문제를 풀면서 각 구간이 정렬된 상태인지 판단하는 조건 (`nums[left] <= nums[mid]` 등)을 정확하게 이해하고 사용하는 것이 해결의 키였다.
- 시간 복잡도 최적화
- 순차 탐색처럼 간단히 풀 수는 있었지만, O(log n)의 시간 복잡도를 요구했기 때문에 이진 탐색의 원리를 잘 이해하고 적용하는 것이 중요했다.
- 회전된 배열 문제에 대한 자신감
    - **이번 문제를 통해 회전된 배열에서 이진 탐색을 적용하는 방식에 대한 자신감을 얻게 되었고, 이와 유사한 문제도 비슷한 원리로 접근할 수 있을 것 같다.**
