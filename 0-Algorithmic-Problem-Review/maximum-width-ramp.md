## [**Maximum Width Ramp**](https://leetcode.com/problems/maximum-width-ramp/)

이 문제는 정수 배열 `nums`에서 **램프의 최대 너비**를 구하는 문제이다.

램프는 배열에서 `(i, j)`라는 쌍으로 정의된다.

이때, `i < j`이고, `nums[i] <= nums[j]`가 성립해야 한다.

즉, `i`와 `j` 사이의 차이가 램프의 너비이다.

## 주요 포인트

1. 가능한 모든 램프 쌍에서 최대 너비를 구하고, 없으면 0을 반환한다.
2. 시간 복잡도가 `O(n^2)`인 brute force 방법은 비효율적이므로 최적화된 방법이 필요하다.
3. 배열을 정렬한 후, 원래 인덱스를 추적할 수 있어야 한다.

## 나의 코드

```tsx
var maxWidthRamp = function(nums) {
  let dif = 0;
  
  for (let i = 0; i < nums.length; i++) {
    for (let j = nums.length - 1; j < i || j - i > dif; j--) {
      if (nums[j] >= nums[i]) {
        dif = j - i;
        continue;
      }
    }
  }

  return dif;
};
```

## 나의 수도 코드

1. `dif`를 `0`으로 초기화 (최대 너비를 저장).
2. `i`를 `0`부터 배열의 길이 - 1까지 순차적으로 반복.
3. `j`를 배열의 끝에서부터 `i`까지 역순으로 순차적으로 반복.
4. `j - i > dif`인 경우에는 더 이상 너비를 갱신할 필요 없으므로 종료 조건.
5. `nums[j] >= nums[i]`인 경우, 즉 `nums[i]`보다 큰 값이 발견되면, `dif`를 `j - i`로 갱신하고 계속 진행.
- `dif` 값을 반환 (최대 램프의 너비).

## 시간 복잡도

1. **외부 반복문 (i)**
    - `i`는 0부터 `nums.length - 1`까지 순회하므로, 반복 횟수는 `O(n)`.
2. **내부 반복문 (j)**
    - `j`는 `nums.length - 1`부터 `i`까지 역순으로 순회.
    - 그러나 내부 조건인 `j - i > dif`에 의해 `dif` 값이 갱신되면, `j`의 범위가 제한될 수 있다. 그래도, 최악의 경우에는 `i`마다 `j`가 0에서 `nums.length - 1`까지 순회할 수 있기 때문에, **내부 반복문**의 시간 복잡도는 `O(n)`이 될 수 있다.

결론적으로, 두 개의 중첩된 반복문이 존재하므로 전체 시간 복잡도는 O(n^2).

## 공간 복잡도

1. **변수 dif**
    - 단 하나의 정수 값만 저장하므로 공간 복잡도는 `O(1)`다.
2. **nums 배열**
    - 주어진 입력이므로 입력 배열 `nums`의 크기에 비례한 공간이 필요하지만, 이는 문제에서 이미 제공된 것이므로 별도로 고려하지 않고 입력 크기 `n`에 따른 공간 복잡도는 고려하지 않는다.

결론적으로 **공간 복잡도는** `O(1)`.

## 다른 사람의 풀이

```tsx
var maxWidthRamp = function(nums) {
  let n = nums.length;
  let stack = [];
  let maxWidth = 0;

  for (let i = 0; i < n; i++) {
    if (stack.length === 0 || nums[i] < nums[stack[stack.length - 1]]) {
      stack.push(i);
    }
  }

  for (let j = n - 1; j >= 0; j--) {
    while (stack.length && nums[j] >= nums[stack[stack.length - 1]]) {
      let i = stack.pop();
      maxWidth = Math.max(maxWidth, j - i);
    }
  }

  return maxWidth;
};
```

## 다른 사람의 수도 코드

1. 배열을 한 번 순회하면서, 각 원소가 이전 원소보다 작은 경우에만 해당 인덱스를 스택에 저장.
2. 배열의 끝에서부터 시작하여, 스택에 있는 인덱스들을 하나씩 꺼내며 `nums[j] >= nums[i]` 조건을 만족하는 인덱스를 찾는다.
3. 해당 조건이 만족되면 `j - i` 값을 계산하여 `maxWidth`를 갱신.
4. 최대 너비인 `maxWidth`를 반환.

## 다른 사람의 시간복잡도

배열을 한 번 순회하고, 스택에서 인덱스를 한 번씩만 꺼내므로 시간 복잡도는 `O(n)`이다.

## 다른 사람의 공간 복잡도

- 배열 `nums`의 모든 인덱스가 스택에 저장될 수 있다.
- 즉, 최악의 경우 `n`개의 인덱스가 스택에 저장될 수 있다.
- 따라서, 스택의 최대 공간은 O(n)이다.

## 알아둬야 할 것!

1. **그리디 알고리즘** : 현재 상태에서 최선의 선택을 반복하여 최적의 해를 구하는 방법.
2. **스택 (Stack)** : LIFO(Last In, First Out) 방식으로 데이터를 저장하고, 빠르게 꺼내는 자료구조.
3. **배열의 인덱스를 스택에 저장** : 배열을 순차적으로 탐색하며 조건에 맞는 인덱스를 스택에 저장. 이때 값이 내림차순으로 쌓임.
4. **배열 뒤에서부터 탐색** : 뒤에서부터 순차적으로 배열을 탐색하여, 스택에 저장된 인덱스를 사용해 조건을 만족하는 `(i, j)` 쌍을 찾아 최대 너비를 구함.
5. **람프 조건** : `(i, j)`에 대해 `nums[i] <= nums[j]`인 쌍을 찾아 최대 너비를 계산.
6. **최대값 갱신** : `(i, j)` 쌍의 너비를 계산하면서 최댓값을 갱신.

## 회고

이 문제를 풀면서 정말 어려움을 겪었다. 처음엔 간단한 배열 문제일 줄 알았지만, 램프 조건을 만족하는 `(i, j)` 쌍을 찾아야 한다는 점에서 막혔다.

특히 스택을 사용해 배열을 두 번 순회하며 최대 너비를 구하는 방식은 이해하기 어려웠다.

왜 스택을 활용해야 하는지, 그리고 그로 인해 효율적인 풀이가 가능한지에 대한 확신이 부족했다.

여러 번 코드에서 오류가 발생했고 좀 더 이해하는 시간이 필요할 것 같다.

그리디 알고리즘과 스택을 활용한 접근 방식을 조사해야겠다.
