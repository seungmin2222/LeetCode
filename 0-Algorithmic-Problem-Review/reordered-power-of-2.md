# [Reordered Power of 2](https://leetcode.com/problems/reordered-power-of-2/)

## 주요 포인트

- n의 자릿수를 재배치해 2의 거듭제곱이 되는지 판단하는 문제.
- 모든 순열을 직접 검사하는 대신, 자릿수 시그니처(정렬 문자열)를 사용하면 효율적.
- 2의 거듭제곱 후보는 2^0부터 2^30까지(10억 이하) 미리 계산 가능.
- n의 시그니처가 미리 만든 시그니처 집합에 포함되는지만 확인하면 됨.

## 나의 코드

```tsx
var reorderedPowerOf2 = function(n) {
  const sig = (x) => x.toString().split('').sort().join('');

  const sigSet = new Set();
  
  for (let p = 1; p <= 1_000_000_000; p <<= 1) {
    sigSet.add(sig(p));
  }

  return sigSet.has(sig(n));
};
```

## 나의 수도 코드

1. sig(x): 숫자 → 문자열 → 문자 배열 → 정렬 → 다시 문자열
2. 빈 Set(sigSet) 생성
3. p = 1부터 p <= 1_000_000_000 까지:
    - sig(p)를 sigSet에 추가
    - p를 2배로 (p <<= 1)
4. n의 시그니처를 구해 sigSet에 포함 여부를 반환

## 시간 복잡도

- 2의 거듭제곱 생성 : 약 30회 → O(1)
- 시그니처 생성 : 자릿수 최대 10자리 → O(d log d) (d ≤ 10 이므로 사실상 O(1))

## 공간 복잡도

- 시그니처 집합 크기: 최대 30개, 길이 ≤ 10 → O(1)

## 알아둬야 할 것!

- 정렬 대신 숫자 빈도 배열을 쓰면 정렬 비용 없이 O(d)로 시그니처 계산 가능.
- 이 방식은 순열 생성보다 훨씬 빠르고 메모리 효율적.

## 회고

처음에는 모든 순열을 만들 생각이었지만, 2의 거듭제곱이 적어서 패턴 매칭 접근이 가능함을 깨달았다.
