## [Rotating the Box](https://leetcode.com/problems/rotating-the-box/)

- 주어진 상자(box) 배열을 90도 시계 방향으로 회전하고, 중력에 의해 돌(`#`)이 아래로 떨어지는 결과를 반환하는 문제이다.

## 주요 포인트

1. **행렬의 회전**
    - 2차원 배열(행렬)을 90도 시계 방향으로 회전시키는 방법.회전 후, 위치 변화는 다음과 같이 이루어진다.
        - `result[col][rows - 1 - row] = original[row][col]`.
2. **중력 시뮬레이션**
    - 돌(`#`)은 중력의 영향을 받아 아래로 떨어진다.
    - 장애물(``)에 막히거나, 다른 돌 위, 혹은 바닥에 멈추게 된다.
    - 빈 공간(`.`)을 활용하여 돌의 위치를 이동시켜야 한다.
3. **2차원 배열의 처리**
    - 각 행 또는 열을 독립적으로 순회하며 돌의 위치를 조정하거나 새 배열을 생성해야 한다.
4. **장애물 처리**
    - 장애물( ``)의 위치는 고정되어 있으며, 이를 기준으로 돌의 위치 조정이 필요한다.

## 나의 코드

```tsx
var rotateTheBox = function(box) {
  const m = box.length; 
  const n = box[0].length;

  for (let i = 0; i < m; i++) {
    let empty = n - 1; 
    
    for (let j = n - 1; j >= 0; j--) {
      if (box[i][j] === '#') {
        box[i][empty] = '#';
        
        if (empty !== j) box[i][j] = '.';
        empty--;
        
      } else if (box[i][j] === '*') {
        empty = j - 1;
      }
    }
  }

  const result = Array.from({ length: n }, () => Array(m).fill('.'));

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
     result[j][m - 1 - i] = box[i][j];
    }
  }

  return result;
}

```

## 나의 수도 코드

1. 행(`m`)과 열(`n`)의 크기를 확인.
2. 각 행을 순회하며 돌(`#`), 장애물(``), 빈칸(`.`)을 처리.
    - 돌(`#`)을 만났다면 가능한 가장 오른쪽의 빈칸(`empty`)으로 이동.
    - 장애물(``)을 만났다면, 장애물 왼쪽의 위치에서부터 다시 중력을 적용.
    - 빈칸(`.`)은 무시.
3. 새로운 크기의 배열(`result`)을 초기화 (크기는 `n x m`).
4. 중력 시뮬레이션이 적용된 원래 배열을 순회하며 90도 시계 방향으로 값을 복사.
5. 회전과 중력 처리가 완료된 배열을 반환.

## 시간 복잡도

1. **중력 시뮬레이션**
    - 각 행(`m`)에서 열(`n`)을 순회하며 중력을 시뮬레이션.
    - 시간 복잡도: O(m×n).
2. **행렬 회전**
    - 원래 배열을 순회하면서 새로운 배열에 복사.
    - 시간 복잡도: O(m × n).

**총 시간 복잡도는 O(m** × **n) 이다.**

## 공간 복잡도

- **1, 입력 배열**
    - 입력 배열의 크기는 O(m×n).
        
        O(m × n)
        
- **결과 배열**
    - 새로운 배열(`result`)의 크기는 O(n×m).
        
        O(n × m)
        

총 공간 복잡도는 O(m×n) 이다.

## 알아둬야 할 것!

1. **2차원 배열 회전의 원리**
    - 90도 시계 방향 회전에서 각 요소의 위치 변화.
        - `result[col][rows - 1 - row] = original[row][col]`.
    - 행렬의 회전은 다양한 문제에서 활용되므로 익혀두기.
2. **중력 시뮬레이션 처리 방식**
    - 장애물(``)을 기준으로 하여 돌(`#`)이 아래로 내려가도록 빈칸(`.`)을 조정.
    - 장애물이 있을 때 중력의 영향을 어떻게 나누어 처리하는지 이해하기.
3. **2차원 배열의 효율적인 순회 방법**
    - 행 우선 순회 또는 열 우선 순회를 문제의 요구에 맞게 구현하는 방법.
4. **시간 및 공간 복잡도 분석**
    - O(m×n) + O(m×n) 복잡도로 문제를 해결할 수 있는 구조 설계.
    - 추가적인 메모리 사용(새로운 배열 생성)을 최소화하려는 시도.

## 회고

이번 문제를 통해 **2차원 배열의 회전**과 **중력 시뮬레이션**의 원리를 명확히 이해할 수 있었다.

행렬 회전 공식과 장애물(`*`)을 기준으로 돌(`#`)이 빈칸(`.`)으로 내려가는 과정을 구현하며 효율적인 배열 처리 방법을 익혔다.

추가 배열 생성으로 인해 메모리 사용이 증가한 점은 아쉬웠지만, 기존 배열을 직접 수정하는 방식을 더 고민해볼 필요성을 느꼈다.

이 로직은 퍼즐 게임이나 물리 시뮬레이션 같은 다양한 문제에도 응용 가능성이 크다고 생각이 된다.

앞으로 유사 문제에서 시간과 공간 효율성을 더 높이는 연습을 해야겠다.
