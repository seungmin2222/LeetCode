## [Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)

이 문제는 주어진 이진 트리에서 루트 노드부터 가장 가까운 **리프 노드**까지의 경로에서 **최소 깊이**를 구하는 문제이다.

## 주요 포인트

- **이진 트리(Binary Tree)**
    - 각 노드는 최대 두 개의 자식을 가질 수 있다.
- **재귀 함수(Recursion)**
    - 트리의 각 노드에 대해 왼쪽과 오른쪽 자식을 반복적으로 탐색하는 방식이다.
    - 재귀를 통해 각 서브트리의 최소 깊이를 찾는다.
- **깊이 우선 탐색(DFS, Depth First Search)**
    - 트리 탐색 기법으로, 루트에서 시작하여 자식 노드를 우선 탐색한 뒤 다시 부모 노드로 돌아오는 방식이다.
    - 이 문제에서는 DFS를 사용하여 트리의 각 경로를 따라가면서 최소 깊이를 계산할 수 있다.
- **리프 노드(Leaf Node)**
    - 자식이 없는 노드로, 트리의 끝을 의미한다. 최소 깊이를 찾기 위해 반드시 리프 노드에 도달해야 한다.

## 나의 코드

```jsx
var minDepth = function(root) {
  if (root === null) return 0;
  
  let min = Infinity;
  
  function dfs(root, val) {
      if (root === null) return;

      if (root.left === null && root.right === null) {
        if (min > val) {
            min = val;
        }
      }

      if (root.left) {
        dfs(root.left, val + 1);
      }

      if (root.right) {
        dfs(root.right, val + 1);
      }
    }
  
  dfs(root, 1);
  
  return min;
};
```

## 나의 수도 코드

1. 함수 minDepth(root)를 정의
    - 만약 root가 null이면 트리는 비어 있는 것이므로 깊이 0을 반환.
2. 변수 min을 무한대로 설정. (최소 깊이를 추적할 변수)
3. 함수 dfs(root, val)를 정의.
    - 만약 root가 null이면 더 이상 탐색할 노드가 없으므로 아무것도 하지 않고 리턴.
    - 만약 현재 노드(root)가 리프 노드(왼쪽 자식과 오른쪽 자식이 모두 없는 경우)라면
        - 현재 깊이 val이 min보다 작으면 min을 현재 깊이로 업데이트.
    - 만약 root의 왼쪽 자식이 존재하면
        - dfs(root의 왼쪽 자식, 현재 깊이 + 1)를 호출하여 왼쪽 서브트리를 탐색.
    - 만약 root의 오른쪽 자식이 존재하면
        - dfs(root의 오른쪽 자식, 현재 깊이 + 1)를 호출하여 오른쪽 서브트리를 탐색.
4. dfs(root, 1)을 호출하여 루트 노드부터 깊이 1로 탐색을 시작.
5. 탐색이 끝난 후, min 값을 반환. (트리의 최소 깊이를 의미함)

## 다른 사람의 풀이

```jsx
var minDepth = function(root) {
    if (root === null) return 0;

    if (root.left === null && root.right === null) return 1;

    if (root.left === null) return minDepth(root.right) + 1;
    if (root.right === null) return minDepth(root.left) + 1;

    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
};
```

## 다른 사람의 수도 코드

1. 함수 minDepth(root)를 정의.
    - 만약 root가 null이면 트리는 비어 있는 것이므로 깊이 0을 반환.
2. 변수 min을 무한대로 설정. (최소 깊이를 추적할 변수)
3. 함수 dfs(root, val)를 정의
    - 만약 root가 null이면 더 이상 탐색할 노드가 없으므로 아무것도 하지 않고 리턴.
    - 만약 현재 노드(root)가 리프 노드(왼쪽 자식과 오른쪽 자식이 모두 없는 경우)
        - 현재 깊이 val이 min보다 작으면 min을 현재 깊이로 업데이트.
    - 만약 root의 왼쪽 자식이 존재
        - dfs(root의 왼쪽 자식, 현재 깊이 + 1)를 호출하여 왼쪽 서브트리를 탐색.
    - 만약 root의 오른쪽 자식이 존재
        - dfs(root의 오른쪽 자식, 현재 깊이 + 1)를 호출하여 오른쪽 서브트리를 탐색.
4. dfs(root, 1)을 호출하여 루트 노드부터 깊이 1로 탐색을 시작.
5. 탐색이 끝난 후, min 값을 반환. (트리의 최소 깊이를 의미함)

## 차이점 비교

1. **재귀 호출 방식**
    - **나의 코드**
        - 명시적인 DFS(깊이 우선 탐색) 방식을 사용하여 루트에서 리프까지 각 경로의 깊이를 계산한 후, `min` 값을 갱신한다.
        - 함수 `dfs`가 깊이를 추적하면서 탐색을 진행하고, 리프 노드에 도달할 때마다 최소 깊이를 업데이트한다.
    - **다른 사람의 코드**
        - 재귀 호출을 통해 각 노드에서 좌우 서브트리의 깊이를 계산한 후, 그 중 최소값을 선택하고 1을 더하는 방식이다.
        - 리프 노드에 도달하면 깊이 1을 반환하고, 서브트리 중 하나가 없을 경우 다른 서브트리의 깊이를 사용한다.
2. **리프 노드 처리**
    - **나의 코드**
        - 리프 노드에 도달했을 때 그 경로의 깊이를 `min` 값과 비교하여 갱신한다.
    - **다른 사람의 코드**
        - 리프 노드에 도달하면 `1`을 반환해 더 이상 깊이를 재귀적으로 계산하지 않고 종료한다.
3. **효율성**:
    - **나의 코드**
        - DFS 방식을 사용하며 깊이를 추적하지만, 재귀 호출마다 변수 `val`을 넘기면서 매번 `min` 값을 비교하고 갱신해야 하므로 약간의 오버헤드가 발생.
    - **다른 사람의 코드**
        - 재귀 호출에서 `Math.min`을 사용하여 깊이를 바로 계산하기 때문에 코드가 더 간결하고 직관적이다.
        - 불필요한 변수를 사용할 필요가 없고, 최소 깊이를 직접적으로 계산해 효율성이 더 높다.
4. **코드의 간결함**
    - **나의 코드는** 깊이 추적을 위한 변수를 따로 관리하고, DFS 함수를 정의하는 등 코드가 더 복잡하다.
    - **다른 사람의 코드** 불필요한 변수가 없고, 재귀 호출을 통해 간결하게 최소 깊이를 계산할 수 있다.

### 최종 비교

- **나의 코드**는 명시적인 DFS 탐색으로 깊이를 추적하며, 각 경로의 깊이를 비교하는 방식이다.
    
    코드의 논리는 분명하지만, 구현이 다소 복잡하고 추가적인 변수가 필요하다.
    
- 다른 사람의 코드는 더 간단하고 효율적인 재귀적 접근 방식으로, 트리의 최소 깊이를 계산하는 가장 직관적인 방법이다.
    
    깊이 추적을 위한 별도의 변수가 필요 없고, 각 서브트리의 최소 깊이를 간단하게 계산할 수 있다.
    

## 알아둬야 할 것!

- **최적화된 재귀 사용법**
    - 재귀 호출을 사용할 때, 불필요한 재귀 호출을 피하는 방법에 대해 생각해야 한다.
    - 하나의 서브트리가 null일 경우, 다른 서브트리만 탐색하면 된다. 이로 인해 불필요한 연산을 줄일 수 있다.
- BFS(너비 우선 탐색, Breadth-First Search)와의 차이
    - 최소 깊이를 찾는 문제는 BFS를 사용해도 풀 수 있다.
    - BFS는 루트에서 가장 가까운 리프 노드를 찾는 데 적합하며, DFS보다 효율적일 수 있다.
    - BFS는 먼저 얕은 노드를 방문하기 때문에 더 빨리 최소 깊이에 도달할 수 있다.

## 회고

이번 문제는 이진 트리에서 최소 깊이를 구하는 문제로, 재귀와 깊이 우선 탐색(DFS) 방법을 사용해 해결했다.

문제를 풀면서 트리 구조의 기본 개념과 재귀적인 탐색 기법에 대한 이해를 다시 한 번 점검할 수 있었다.

특히, 재귀를 사용할 때 호출되는 각 노드의 상태를 추적하고, 최소 깊이를 찾기 위한 최적화 방법을 고려하는 과정이 중요했다.
