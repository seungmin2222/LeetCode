## [**Unique Paths**](https://leetcode.com/problems/unique-paths)

주어진 격자에서 시작점(0, 0)에서 끝점(m-1, n-1)까지 이동하는 모든 가능한 경로의 수를 구하는 문제로, 오직 오른쪽과 아래 방향으로만 이동할 수 있다.

## 주요 포인트

- **재귀와 메모이제이션**
    - 재귀를 사용하여 문제를 해결할 때, 중복 계산을 줄이기 위해 메모이제이션 기법을 사용하는 방법을 이해해야 한다.
- **경로 수 계산 이해**
    - 격자에서의 경로 문제는 조합론적 접근이 가능하며, 이동 경로를 결정하는 데 필요한 조건(오른쪽 및 아래 이동)을 명확히 인식해야 한다.

## 나의 코드

```jsx
var uniquePaths = function(m, n) {
  let memo = {};

  function walk(x, y) {
    if (x === m - 1 && y === n - 1) {
      return 1;
    }
    
    if (x >= m || y >= n) {
      return 0;
    }
    
    if (`${x},${y}` in memo) {
      return memo[`${x},${y}`];
    }
    
    memo[`${x},${y}`] = walk(x + 1, y) + walk(x, y + 1);
    return memo[`${x},${y}`];
  }

  return walk(0, 0);
};

```

## 나의 수도 코드

1. 빈 메모이제이션 객체 `memo`를 생성한다.
2. 함수 `walk(x, y)`를 정의한다.
3. 만약 `x == m - 1` 그리고 `y == n - 1` 이면, `1`을 반환한다.
4. 만약 `x >= m` 또는 `y >= n` 이면, `0`을 반환한다.
5. 만약 `(x, y)`가 `memo`에 존재하면, `memo[(x, y)]`를 반환한다.
6. 그렇지 않으면, `memo[(x, y)] = walk(x + 1, y) + walk(x, y + 1)`을 계산한다.
7. `memo[(x, y)]`를 반환한다.
8. `walk(0, 0)`을 호출하고 그 결과를 반환한다.

## 다른 사람의 풀이

```jsx
var uniquePaths = function(m, n) {
  const dp = Array.from({ length: m }, () => Array(n).fill(0));

  dp[0][0] = 1;

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (i > 0) {
        dp[i][j] += dp[i - 1][j];
      }
      if (j > 0) {
        dp[i][j] += dp[i][j - 1];
      }
    }
  }

  return dp[m - 1][n - 1];
};
```

## 다른 사람의 수도 코드

- **배열 초기화**
    - `dp`라는 2D 배열을 생성하여 각 셀에 도달할 수 있는 경로 수를 저장한다.
    - 초기값은 모두 `0` 이다.
- **시작 위치 설정**
    - `dp[0][0]`을 `1`로 설정하여 시작점에서의 경로 수를 초기화한다.
- **셀 순회**
    - 두 개의 중첩 `for` 루프를 사용하여 모든 셀을 순회한다.
    - 각 셀 `(i, j)`
        - 위쪽 셀 `(i-1, j)`에서 오는 경로 수를 더한다 (i가 0보다 클 경우).
        - 왼쪽 셀 `(i, j-1)`에서 오는 경로 수를 더한다 (j가 0보다 클 경우).
- **결과 반환**
    - 목표 위치인 `(m-1, n-1)`에서의 경로 수를 반환한다.

## 알아둬야 할 것!

- **재귀와 메모이제이션의 이해**
    - 재귀는 큰 문제를 작은 하위 문제로 분할하여 해결한다.
    - 메모이제이션은 이미 계산된 하위 문제의 결과를 저장하여 중복 계산을 방지한다.
    - 하지만 재귀 깊이가 깊어지면 스택 오버플로우의 위험이 있다.
- **동적 프로그래밍(DP)의 개념**
    - DP는 복잡한 문제를 작은 하위 문제로 분할하고, 그 결과를 저장하여 전체 문제를 해결한다.
    - 보텀업(Bottom-Up) 방식으로 작은 문제부터 해결해 나간다.
    - 이 문제에서는 각 셀까지의 경로 수를 저장하여 다음 계산에 활용한다.
- **시간 및 공간 복잡도 분석**
    - 알고리즘의 효율성을 평가하기 위해 시간과 공간 복잡도를 이해해야 한다.
    - 재귀는 간결하지만, 반복문을 사용하는 DP가 더 효율적일 수 있다.
- **수학적 접근법의 활용**
    - 이 문제는 조합론적으로도 해결 가능하다.
    - 총 이동 횟수는 `(m - 1) + (n - 1)`이며, 이 중에서 `(m - 1)`번을 아래로 이동하는 경우의 수를 계산하면 된다.
    - 조합 공식을 사용하여 `C(m + n - 2, m - 1)` 또는 `C(m + n - 2, n - 1)`로 계산할 수 있다.
- **최적화 방법의 선택**
    - 입력 크기에 따라 적절한 알고리즘을 선택해야 한다.
    - 작은 입력에서는 재귀와 메모이제이션도 충분하지만, 큰 입력에서는 DP나 수학적 공식을 사용하는 것이 좋다.
- **자료 구조의 효율적 사용**
    - 2D 배열 대신 1D 배열로 공간 복잡도를 줄일 수 있다.
    - 예를 들어, 현재 행의 값만 저장하여 이전 행의 값을 재사용할 수 있다.
- **문제 해결 전략**
    - 문제의 특성을 파악하여 적합한 알고리즘을 적용한다.
    - 중복되는 하위 문제가 있다면 DP를, 그렇지 않다면 다른 알고리즘을 고려한다.

## 회고

이번 문제는 격자에서의 경로 수를 계산하는 전형적인 동적 프로그래밍 문제였다.

처음에는 재귀와 메모이제이션을 사용하여 시작점에서 끝점까지 이동하는 경로 수를 계산했는데, 이 방식은 이해하기 쉬웠지만 큰 입력에 대해 비효율적일 수 있었다.

동적 프로그래밍을 활용하여 2D 배열을 사용해 각 셀까지의 경로 수를 계산하는 방법으로 푼 코드를 봤다.

이 방법은 반복문을 통해 모든 경로를 체계적으로 계산하므로 속도가 빨라지고 중복 계산을 방지하는 것을 보았다.

이 과정에서 동적 프로그래밍의 장점을 다시 한번 실감했으며, 하위 문제의 결과를 저장해 두는 것이 얼마나 중요한지를 깨달았습니다.
이러한 경험은 앞으로의 문제를 해결하는 데 유용한 전략으로 작용할 것입니다.
