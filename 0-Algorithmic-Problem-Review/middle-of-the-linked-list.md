## [**Middle of the Linked List**](https://leetcode.com/problems/middle-of-the-linked-list)

이 문제는 주어진 단일 연결 리스트의 중간 노드를 반환하는 문제다.

## 주요 포인트

1. 연결 리스트의 모든 노드를 배열에 저장한다.
2. 배열의 길이를 이용하여 중간 인덱스를 계산한다.
3. 중간 인덱스에 해당하는 노드를 반환한다.
4. 추가적인 메모리 사용에 대한 고려가 필요하다.

## 나의 코드

```jsx
var middleNode = function(head) {
  const nodes = [];
  let current = head;
  
  while (current !== null) {
    nodes.push(current);
    current = current.next;
  }

  const middleIndex = Math.floor(nodes.length / 2);

  return nodes[middleIndex];
};
```

## 나의 수도 코드

1. 함수 middleNode(head)를 정의
2. nodes라는 빈 배열을 생성
3. current를 head로 초기화
4. current가 null이 아닐 때까지 반복
    - nodes에 current를 추가
    - current를 current.next로 업데이트
5. middleIndex를 floor(nodes.length / 2)로 계산
6. nodes[middleIndex]를 반환

## 다른 사람의 풀이

```jsx
var middleNode = function(head) {
  let slow = head;
  let fast = head;
  
  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
  }
  
  return slow;
};
```

1. 두 개의 포인터 `slow`와 `fast`를 `head`로 초기화
2. `fast`가 리스트의 끝에 도달할 때까지 반복
    - `slow`는 한 번에 한 노드씩 이동
    - `fast`는 한 번에 두 노드씩 이동
3. `fast`가 끝에 도달하면, `slow`는 중간 노드를 가리키게 됨
4. `slow`를 반환

## 나의 코드와 차이점

- **공간 복잡도:**
    - 나의 **코드:** 연결 리스트의 모든 노드를 배열 `nodes`에 저장하여 추가적인 O(n) 공간을 사용한다.
    - 다른 사람의 **코드:** 추가적인 배열 없이 포인터만 사용하여 O(1) 공간 복잡도를 가진다.
- **시간 복잡도:**
    - **두 코드 모두:** 연결 리스트를 한 번 순회하므로 O(n)의 시간 복잡도를 갖는다.
- **알고리즘 접근 방식:**
    - 나의 **코드**
        - 연결 리스트의 모든 노드를 배열에 저장하고
        - 배열의 길이를 이용하여 중간 인덱스를 계산하고 해당 노드를 반환한다.
    - 다른 사람의 **코드**
        - 두 개의 포인터 `slow`와 `fast`를 사용하여 `fast`는 두 칸씩, `slow`는 한 칸씩 이동한다.
        - `fast`가 리스트의 끝에 도달하면 `slow`는 중간 노드를 가리키게 된다.
- **효율성:**
    - **나의 코드:** 추가적인 메모리 사용으로 인해 공간 효율성이 조금 떨어진다.
    - 다른 사람의 **코드:** 메모리 사용을 최소화하여 더 효율적이며, 대용량 데이터에서도 성능이 향상된다.

## 알아둬야 할 것!

- **연결 리스트의 기본 개념 이해**
    - 연결 리스트는 노드들이 순차적으로 연결된 자료 구조로, 각 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있다.
    - 임의의 위치에 접근하려면 처음부터 순회해야 하므로, 중간 노드를 찾기 위해서는 효율적인 방법이 필요합니다.
- **효율적인 알고리즘의 중요성**
    - 시간 복잡도와 공간 복잡도를 고려하여 알고리즘을 설계해야 한다.
    - 추가적인 메모리 사용(O(n) 공간 복잡도)을 최소화하는 것이 바람직히디/
- **두 포인터 기법 (빠른 포인터와 느린 포인터)**
    - 빠른 포인터는 한 번에 두 노드씩 이동하고, 느린 포인터는 한 번에 한 노드씩 이동한다.
    - 빠른 포인터가 리스트의 끝에 도달했을 때, 느린 포인터는 중간 노드를 가리키게 된다.
    - 이 방법은 O(n) 시간 복잡도와 O(1) 공간 복잡도를 가진다.
- **알고리즘의 선택과 trade-off:**
    - 배열을 사용하면 구현이 직관적이지만 메모리를 더 사용해야 한다.
    - 반면에 두 포인터를 사용하는 방법은 메모리 효율적이지만 구현이 조금 더 복잡할 수 있다.

## 회고

이번 문제를 통해 연결 리스트의 중간 노드를 찾는 다양한 방법에 대해 고민하게 되었다.

처음에는 배열을 사용하여 간단하게 해결할 수 있었지만, 추가적인 O(n)의 공간 복잡도가 발생한다는 한계를 알게 되었다.

두 포인터 기법을 적용하면서 공간 복잡도를 O(1)로 줄일 수 있었고, 특히 대용량 데이터 처리 시에 이점이 크다는 것을 느꼈다.

알고리즘을 설계할 때 단순히 작동하는 코드 작성에 그치지 않고, 자원 활용의 효율성도 중요하다는 것을 다시 한번 깨달았다.

앞으로 문제를 해결할 때 다양한 접근 방식을 고려하고, 그중에서 가장 효율적인 방법을 선택하는 노력을 해야겠다고 생각했다.
