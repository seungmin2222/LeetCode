## [**Minimum Length of String After Operations**](https://leetcode.com/problems/minimum-length-of-string-after-operations/)

1. 문자열의 인덱스 `i`를 선택한다. 이때, `s[i]`와 같은 문자가 인덱스 `i`의 왼쪽과 오른쪽에 각각 최소 하나 이상 존재해야 한다.
2. 인덱스 `i`의 왼쪽에서 가장 가까운 `s[i]`와 같은 문자를 삭제한다.
3. 인덱스 `i`의 오른쪽에서 가장 가까운 `s[i]`와 같은 문자를 삭제한다.

최종적으로 얻을 수 있는 문자열의 최소 길이를 구하는 문제이다.

## 주요 포인트

1. **문자 빈도수 계산**
    - 각 문자가 문자열 `s`에 몇 번 등장하는지 계산한다.
2. **연산 가능한 횟수 계산**
    - 각 문자에 대해, 해당 문자를 중심으로 연산을 수행할 수 있는 최대 횟수를 계산한다.
    - 한 번의 연산은 동일한 문자를 두 번 삭제하므로, 각 문자의 등장 횟수에서 1을 뺀 후 2로 나눈 값의 정수 부분(`Math.floor((count - 1) / 2)`)이 해당 문자를 중심으로 수행할 수 있는 연산 횟수가 된다.
3. **최종 문자열 길이 계산**
    - 모든 문자에 대해 가능한 연산 횟수를 합산한 후, 이를 이용해 삭제되는 문자의 총 개수를 계산한다.
    - 최종 문자열의 최소 길이는 원래 문자열의 길이에서 삭제된 문자의 개수를 뺀 값이 된다.

## 나의 코드

```jsx
var minimumLength = function(s) {
    const freq = {};
    for (let char of s) {
        freq[char] = (freq[char] || 0) + 1;
    }

    let totalOperations = 0;
    for (let char in freq) {
        const count = freq[char];
        if (count >= 3) {
            totalOperations += Math.floor((count - 1) / 2);
        }
    }

    const deletions = totalOperations * 2;
    return s.length - deletions;
};
```

## 나의 수도 코드

1. **빈도수 계산 :** 문자열 내 각 문자의 등장 횟수를 센다.
2. **삭제 수 계산 :** 각 문자의 빈도수가 3 이상일 때, 가능한 연산 횟수를 계산하고 삭제할 문자의 수를 합산한다.
3. **최소 길이 도출 :** 원래 문자열의 길이에서 삭제된 문자의 수를 빼서 최소 길이를 구한다.
4. **결과 반환 :** 계산된 최소 길이를 반환한다.

## 시간 복잡도

여기서 N은 문자열 `s`의 길이다.

문자열을 한 번 순회하여 빈도수를 계산하고, 빈도수 맵을 순회하여 연산 횟수를 계산하기 때문이다.

최종 시간 복잡도는 O(N).

## 공간 복잡도

소문자 영어 문자만 사용하므로 최대 26개의 문자에 대한 빈도수만 저장하면 된다.

최종 공간 복잡도는 O(1).

## 다른 사람의 풀이

## 알아둬야 할 것!

- **Queue (큐) 자료구조**
    - 선입선출(FIFO) 방식으로 데이터를 처리하는 자료구조이다.
    - 연산 가능한 노드를 순차적으로 처리하기 위해 사용된다.
- **Efficient String Manipulation**
    - 큰 문자열에서 빈번한 삽입과 삭제는 비효율적일 수 있으므로, 적절한 자료구조(예: 링크드 리스트)를 사용하여 성능을 최적화한다.
- **Active Flagging**
    - 노드의 활성 여부를 추적하여, 이미 삭제된 노드를 다시 처리하지 않도록 한다.
    - 이는 불필요한 연산을 방지하고 알고리즘의 효율성을 높힌다.

## 회고

이번 문제는 문자열에서 특정 조건을 만족하는 연산을 통해 최소 길이를 구하는 문제로, 단순한 빈도수 계산만으로는 해결되지 않는 복잡한 상황을 포함하고 있었다.

초기에는 각 문자의 빈도수를 기반으로 접근하려 했으나, 실제로는 문자들의 위치와 연속성이 중요한 역할을 한다는 것을 깨달았다.

이를 해결하기 위해 Doubly Linked List를 활용한 접근 방식을 도입함으로써, 문자열 내에서 효율적으로 연산 가능한 문자를 찾고 삭제할 수 있었다.

이 과정에서 자료구조의 선택이 문제 해결에 얼마나 중요한지 다시 한번 느꼈다. 이번 문제를 통해 자료구조와 알고리즘의 적절한 활용이 복잡한 문제를 효과적으로 해결하는 데 필수적임을 학습하게 되었습니다.
