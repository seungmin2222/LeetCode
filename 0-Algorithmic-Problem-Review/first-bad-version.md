## [**First Bad Version**](https://leetcode.com/problems/first-bad-version)

이 문제는 주어진 API `isBadVersion(version)`을 사용하여 버전 1부터 n까지 중 첫 번째로 불량한 버전을 찾아내는 문제이다. 첫 번째 불량 버전 이후의 모든 버전은 불량이다.

## 주요 포인트

1. **이진 탐색**을 사용하여 불량 버전을 효율적으로 찾는 것이 핵심이다.
2. `left`와 `right`로 범위를 설정하고, 중간값 `mid`를 계산해 불량 여부를 확인한다.
3. `isBadVersion(mid)`가 참이면 첫 번째 불량 버전이 `mid` 이하에 있으므로 `right`를 `mid`로 설정한다.
4. 반대로 `mid`가 불량이 아니면, 첫 번째 불량 버전이 그 이후에 있으므로 `left`를 `mid + 1`로 설정한다.

## 나의 코드

```jsx
/**
 * Definition for isBadVersion()
 * 
 * @param {integer} version number
 * @return {boolean} whether the version is bad
 * isBadVersion = function(version) {
 *     ...
 * };
 */

/**
 * @param {function} isBadVersion()
 * @return {function}
 */
var solution = function(isBadVersion) {
    /**
     * @param {integer} n Total versions
     * @return {integer} The first bad version
     */
    return function(n) {
        let left = 1;
        let right = n;

        while (left < right) {
            let mid = Math.floor((left + right) / 2);
            if (isBadVersion(mid)) {
                right = mid; 
            } else {
                left = mid + 1;
            }
        }

        return left;
    };

};
```

## 나의 수도 코드

1. `left`를 1로, `right`를 n으로 초기화한다.
2. `left`가 `right`보다 작을 동안 반복한다:
    - `mid`를 `left`와 `right`의 중간값으로 설정한다.
    - 만약 `isBadVersion(mid)`가 참이면, `right`를 `mid`로 설정한다.
    - 그렇지 않으면, `left`를 `mid + 1`로 설정한다.
3. 반복문이 종료되면, `left`를 반환한다. 이 값이 첫 번째 불량 버전이다.

## 알아둬야 할 것!

- **탐색 최적화**
    - 순차적으로 버전을 확인하면 시간 복잡도가 **O(n)**이 되어 성능 문제가 발생할 수 있다.
    - 이진 탐색을 사용하면 탐색 범위를 절반씩 줄이면서 시간 복잡도를 O(log n)으로 개선할 수 있다.
- **이진 탐색 활용**
    - 중간값을 기준으로 범위를 좁혀가며 탐색하는 이진 탐색은 정렬된 데이터에서 빠르게 답을 찾을 수 있는 중요한 알고리즘이다.
    특히, 탐색 범위를 반으로 줄여나가는 방식은 대규모 데이터에서 매우 유용하다.

## 회고

처음 이 문제를 접했을 때, 가장 직관적인 방법은 **순차 탐색(Linear Search)** 방식으로 1번 버전부터 시작해 하나씩 `isBadVersion()` 함수를 호출하면서 확인하는 방법이었다. 즉, 첫 번째 버전부터 시작하여 `isBadVersion()`이 `true`를 반환하는 첫 번째 버전을 찾으면 그 버전이 바로 우리가 찾는 첫 번째 불량 버전이므로 이를 반환하는 방식이었다.

### 1. 초기 접근: 순차 탐색

순차적으로 탐색하면 간단히 문제를 풀 수 있겠다는 생각이 들었고, 코드를 아래와 같이 작성했다.

```jsx
for (let i = 1; i <= n; i++) {
    if (isBadVersion(i)) {
        return i;
    }
}
```

이 방식은 매우 직관적이었고, 작은 테스트 케이스에서는 정상적으로 동작했다. 하지만 **버전의 개수가 매우 클 경우**(예: 수백만 개)에는 시간이 너무 오래 걸리게 되었다. 모든 버전을 하나하나 확인해야 하기 때문에, 최악의 경우에는 `n`번 `isBadVersion()`을 호출해야 했다. 실제로 문제의 제한 시간(Time Limit)이 있었고, 순차 탐색으로는 제한 시간을 초과해서 **Time Limit Exceeded(TLE)** 에러가 발생했다.

### 2. 새로운 접근법: 이진 탐색(Binary Search)으로 최적화

문제 해결 시간이 너무 오래 걸린다는 문제를 해결하기 위해 다시 고민을 시작했다. 문제의 본질을 생각해보니, **첫 번째 불량 버전 이후 모든 버전이 불량**이라는 중요한 단서를 발견할 수 있었다. 이 특성 덕분에, 굳이 모든 버전을 하나씩 확인하지 않고, **탐색 범위를 절반씩 줄여나가면서** 해결할 수 있겠다는 생각이 들었다.

이때 떠오른 것이 바로 **이진 탐색(Binary Search)** 방법이었다. 이진 탐색은 정렬된 데이터에서 중간값을 기준으로 탐색 범위를 절반씩 줄여나가는 방식으로, 시간 복잡도를 O(n)에서 O(log n)으로 줄일 수 있다. 버전들이 순서대로 주어져 있고, 불량 버전 이후는 전부 불량이기 때문에 이진 탐색을 적용하는 것이 적합하다고 판단했다.

### 3. 이진 탐색 구현

- 중간값(`mid`)을 계산한 후, 해당 버전이 불량인지(`isBadVersion(mid)`) 확인.
    - **만약 중간값이 불량 버전이라면**, 첫 번째 불량 버전은 `mid`이거나 그 이전에 있을 가능성이 있으므로 탐색 범위를 왼쪽으로 좁힌다. (`right = mid`)
    - **만약 중간값이 불량 버전이 아니라면**, 첫 번째 불량 버전은 그 이후에 있을 가능성이 있으므로 탐색 범위를 오른쪽으로 좁힌다.. (`left = mid + 1`)
- 이 과정을 반복하면서 `left`와 `right`가 동일해질 때, `left`가 첫 번째 불량 버전을 가리키게 된다.

### 4. 결과

이진 탐색을 적용하니, 시간 복잡도는 O(log n)으로 대폭 줄었고, 수백만 개의 버전이 주어져도 제한 시간 내에 첫 번째 불량 버전을 빠르게 찾아낼 수 있었다. 문제에서 요구하는 성능 조건을 만족시킬 수 있었다.

### 5. 마무리

이 문제를 풀면서 얻은 가장 큰 교훈은 **문제의 특성**을 파악하는 것이 얼마나 중요한지였다. 처음에는 순차 탐색이라는 직관적인 방식으로 접근했지만, 문제의 조건(첫 번째 불량 이후 모든 버전이 불량하다는 것)을 제대로 이해하고 나니, 이진 탐색으로 탐색 범위를 효율적으로 줄일 수 있었다.

따라서, 복잡한 문제를 만났을 때는 단순한 방식으로 풀어보고, 성능에 문제가 생기면 문제의 본질을 다시 한 번 고민해보는 것이 좋다는 것을 배웠다. 특히 **탐색**과 관련된 문제에서는 이진 탐색이 강력한 도구가 될 수 있음을 다시 한 번 느꼈다.
