## [**Zigzag Conversion**](https://leetcode.com/problems/zigzag-conversion/)

주어진 문자열을 지그재그(Zigzag) 패턴으로 배치하고 각 행을 이어붙인 문자열을 반환하는 문제이다.

`numRows`는 지그재그 패턴의 행 수를 나타낸다.

## 주요 포인트

- **지그재그 패턴**
    - 문자열을 행렬처럼 배치하지만, 행을 순서대로 이동하다가 맨 위나 맨 아래에서 방향을 바꾸는 패턴.
    - "아래로 내려가기 -> 방향 전환 -> 위로 올라가기"가 반복.
- **행과 열의 개념**
    - `numRows`는 행(row)의 수를 나타내며, 주어진 문자열의 각 문자가 특정 행에 위치.
    - 열(column)은 패턴에서 중요하지 않으며, 행의 순서에 집중.
- **방향 전환**
    - 특정 조건(`line === 0` 또는 `line === numRows - 1`)에서 방향이 바뀌어야 .
    - "아래로 → 위로"와 "위로 → 아래로"를 전환하는 방법이 핵심.
- **1차원 배열 사용**
    - 각 행에 해당하는 문자열을 저장할 배열(`rows`)이 필요하며, 결과를 만들기 위해 이를 합침.

## 나의 코드

```tsx
var convert = function(s, numRows) {
  if (numRows === 1) return s; 

  let arr = new Array(numRows).fill("").map(() => "");
  let line = 0;
  let isPlus = 1; 

  for (let i = 0; i < s.length; i++) {
    arr[line] += s[i];

    
    if (line === numRows - 1) {
      isPlus = -1; 
    } else if (line === 0) {
      isPlus = 1; 
    }

    line += isPlus;
  }

  return arr.join("");
};

```

## 나의 수도 코드

1. **예외 처리**
    - 만약 `numRows == 1` 또는 `s.length <= numRows`라면, 입력 문자열 `s`를 그대로 반환.
2. **데이터 구조 초기화**
    - `rows`라는 배열을 길이 `numRows`로 초기화하고 각 요소를 빈 문자열로 설정.
    - `line` 변수를 0으로 초기화하여 현재 행을 추적.
    - `isGoingDown` 변수를 `false`로 초기화하여 방향을 나타남.
3. **문자열 반복 처리**
    - 문자열 `s`의 각 문자를 순서대로 처리함.
        - 현재 행(`line`)에 해당하는 배열 요소에 문자를 추가함.
        - 만약 `line == 0` 또는 `line == numRows - 1`이면 `isGoingDown` 값을 반전.
        - 방향에 따라 `line` 값을 증가하거나 감소.
4. **결과 생성**
    - `rows` 배열의 모든 문자열을 합쳐서 하나의 문자열로 반환.

## 시간 복잡도

1. **문자열 순회**
    - 입력 문자열 `s`의 길이를 `n`이라고 할 때, 각 문자를 한 번씩 순회.
    - 이 루프는 **O(n)**.
2. **문자 추가**
    - 각 문자는 한 번의 문자열 연결 연산을 수행.
    - 따라서 이 단계는 순회와 함께 O(n).
3. **결과 문자열 생성**
    - `rows` 배열에 저장된 모든 문자열을 합침.
    - 문자열 연결 작업의 총 비용은 각 행의 문자열 길이의 합으로, 최종적으로 입력 문자열의 길이 `n`만큼 연결.
    - 결과적으로 이 단계도 **O(n)**.

**최종 시간복잡도**

- O(n) + O(n) = **O(n)**

## 공간 복잡도

1. **배열 `rows`**
    - 행(row)마다 문자열을 저장하므로 `rows` 배열의 크기는 `numRows`.
    - 배열 내부의 모든 문자열을 합친 총 길이는 입력 문자열의 길이 `n`.
    - 공간복잡도는 각 행 문자열의 저장 비용을 포함하여 **O(n)**.
2. **기타 변수**
    - `line`, `isGoingDown` 등 상수 크기의 변수는 공간복잡도에 영향을 미치지 않는다.

**최종 공간복잡도**

- 입력 문자열 크기와 행(row) 배열 크기에 비례하여 **O(n).**

## 알아둬야 할 것!

1. **시간복잡도와 공간복잡도 분석**
    - 시간복잡도는 O(n): 입력 문자열을 순회하면서 각 문자를 처리.
    - 공간복잡도는 O(n): 각 행에 저장되는 문자들이 모두 입력 문자열의 길이에 비례.
2. **지그재그 패턴의 구현 방식**
    - 행(`line`)과 방향(`isGoingDown`)을 사용하여 "아래로 내려가기 → 방향 전환 → 위로 올라가기"를 반복적으로 구현.
    - 행의 방향 전환 조건(`line == 0` 또는 `line == numRows - 1`)이 중요.
3. **행(row) 기반 접근법**
    - 문자열을 2차원적으로 생각하지만 실제로는 1차원 배열(`rows`)에 각 행을 문자열로 저장.
    - 행렬 대신 간단한 배열을 사용하여 메모리 사용을 최적화.
4. **문자열 병합의 효율성**
    - JavaScript 문자열 병합 연산 (`+=`)이 효율적으로 구현되어 있어 최종 결과 생성이 빠르게 처리됨.

## 회고

이번 문제는 문자열을 지그재그 패턴으로 변환한 후 이를 다시 이어붙이는 작업으로, 패턴에 따른 행(row) 관리와 방향 전환 로직이 핵심이었다.

구현 과정에서 행의 개수와 방향 전환 조건을 명확히 이해하는 것이 중요했으며, 이를 통해 간단한 1차원 배열 기반의 효율적인 해결책을 도출할 수 있었다.

시간복잡도와 공간복잡도를 분석하며 O(n)으로 최적화된 솔루션을 확인할 수 있었다.

이 문제를 통해 패턴 기반 문자열 처리와 효율적인 데이터 구조 사용의 중요성을 다시 한 번 느꼈다.
