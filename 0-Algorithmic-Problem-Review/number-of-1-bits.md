# [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/submissions/)

이 문제는 주어진 정수 `n`의 이진수 표현에서 '1'의 개수를 계산하는 문제다. 

이진수에서 '1'의 개수는 Hamming Weight 또는 팝카운트라고도 불린다.

## 주요 포인트

1. 두 트리의 구조가 동일해야 한다.
2. 각 노드의 값이 같아야 한다.

## 나의 코드

```jsx
var hammingWeight = function(n) {
  const binary = n.toString(2);
  let count = 0;
  
  for (let i = 0; i < binary.length; i++) {
    if (binary[i] === '1') {
        count++
    }
  }
  
  return count;
};
```

## 나의 수도코드

1. n을 이진수 문자열로 변환하여 binary 변수에 저장한다.
2. count 변수를 0으로 초기화한다.
3. 이진수 문자열의 각 자릿수를 순회한다.
    - 만약 현재 자릿수가 '1'이라면 count를 1 증가시킨다.
4. count 값을 반환한다.

## 다른 사람의 코드

```jsx
var hammingWeight = function(n) {
    let count = 0;
    while (n !== 0) {
        count += n & 1;
        n >>>= 1;
    }
    return count;
};
```

1. **비트 연산**
    - 이진수로 변환하지 않고 비트 연산을 직접 사용하여 '1'의 개수를 센다.
2. **비트 시프트 연산**
    - `n`을 오른쪽으로 한 비트씩 시프트하여, 이미 확인한 비트는 버린다. `>>>` 연산은 부호 비트를 무시하고 시프트를 수행한다.

## 알아둬야 할 것!

- **이진수(binary number)**
    - 정수를 이진수로 변환하는 방법을 이해해야 한다.
- **비트 연산(bit manipulation)**
    - 이진수에서 비트(0 또는 1)를 다루는 방법을 이해해야 한다.
    특히, 특정 비트가 1인지 확인하거나, 비트의 개수를 세는 것이 중요하다.
- **Hamming Weight (팝카운트)**
    - Hamming Weight는 이진수에서 '1'의 개수를 세는 개념으로, 이 문제의 핵심이다.
    이는 컴퓨터 과학에서 흔히 사용되는 연산으로, 특정 비트 패턴을 분석하거나 데이터 무결성을 확인할 때 유용하다.
## **회고**

**나의 코드**

- **장점**
    - 코드가 직관적이고, 이진수 변환 후 순회하여 '1'의 개수를 세는 방식이 이해하기 쉽다.
    - 코드의 가독성이 높으며, 이진수 변환을 통해 비트 수준에서의 동작을 쉽게 시각화할 수 있습니다.
- **단점**
    - 이진수 변환 과정이 추가되어 성능상 비효율적이다.
    - 큰 수에 대해 비트 변환과 순회를 수행하기 때문에 시간과 메모리 측면에서 비효율적일 수 있다.

**다른 사람의 코드**

- **장점**
    - 비트 연산을 직접 사용하여, 이진수로 변환하지 않고 '1'의 개수를 센다.
    - 메모리 사용량이 줄어들고, 더 빠른 실행이 가능하다.
    - 코드의 시간 복잡도는 동일하게 O(k)지만, 상수 시간에서 이점이 있다.
- **단점**
    - 비트 연산에 익숙하지 않은 개발자에게는 이해하기 어려울 수 있다.

원래 코드도 문제를 해결할 수 있었지만, 비트 연산을 활용한 최적화 코드는 더 효율적이었다.

---

비트 연산을 이해하고 활용하는 코드를 볼 수 있어서 좋았다.

앞으로 비트 연산에 대해 더 깊이 공부하고, 이를 코드에 적용할 수 있도록 해야겠다.
