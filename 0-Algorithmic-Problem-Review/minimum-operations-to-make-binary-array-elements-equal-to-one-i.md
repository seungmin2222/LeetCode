# [Minimum Operations to Make Binary Array Elements Equal to One I](https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/)

이 문제는 배열의 모든 요소를 1로 만들기 위한 최소 연산 횟수를 구하는 문제이다.

연산은 연속된 3개의 요소를 한 번에 뒤집는 것이다.

## 주요 포인트

1. 항상 왼쪽에서 오른쪽으로 진행하며, 현재 위치가 0이면 그 위치부터 3개의 요소를 뒤집는다.
2. 같은 위치를 두 번 뒤집으면 원래 상태로 돌아가므로, 각 위치는 최대 한 번만 연산의 시작점이 된다.
3. 첫 번째 요소부터 순서대로 처리하면 항상 최적의 결과를 얻을 수 있다.

## 나의 코드

```javascript
var minOperations = function(nums) {
    const n = nums.length;
    
    if (n < 3) {
        return nums.every(num => num === 1) ? 0 : -1;
    }
    
    let operations = 0;
    
    for (let i = 0; i < n - 2; i++) {
        if (nums[i] === 0) {
            nums[i] ^= 1;
            nums[i+1] ^= 1;
            nums[i+2] ^= 1;
            operations++;
        }
    }
    
    if (nums[n-2] === 1 && nums[n-1] === 1) {
        return operations;
    }
    
    return -1;
};
```

## 나의 수도 코드

1. 배열 길이가 3보다 작은 경우, 모든 요소가 이미 1이면 0을 반환하고, 그렇지 않으면 -1을 반환.
2. 배열을 복사하고 왼쪽에서 오른쪽으로 진행
    - 현재 위치 `i`의 값이 0이면, 위치 `i`, `i+1`, `i+2`의 값을 뒤집고 연산 횟수를 증가.
3. 마지막 두 요소를 확인하여 모든 요소가 1이 되었는지 확인.
    - 마지막 두 요소가 모두 1이면 연산 횟수를 반환.
    - 그렇지 않으면 불가능한 경우이므로 -1을 반환.

## 시간 복잡도

배열을 한 번만 순회한다.

최종 시간 복잡도는 O(1)이다.

## 공간 복잡도

단순 상수만 있으므로  최종 공간 복잡도는 O(1)이다.

## 알아둬야 할 것!

1. 비트 연산자(Bitwise Operators)
    - XOR(`^`)과 같은 비트 연산자를 이용하면 0과 1을 토글하는 작업을 효율적으로 수행할 수 있다.
2. 귀납적 사고(Inductive Reasoning)
    - 왼쪽에서 오른쪽으로 처리할 때 항상 최적해를 얻을 수 있다는 증명에 필요한 사고방식이다.

## 회고

이 문제를 풀면서 그리디 접근법의 증명이 중요하다는 것을 깨달았다.

처음에는 여러 시작점을 고려했지만, 왼쪽에서 오른쪽으로 순차 처리하는 단순한 방법이 최적해를 보장한다는 점이 흥미로웠다. XOR 연산자로 코드를 간결하게 작성할 수 있었고, 이는 비트 관련 문제에서 유용한 패턴이다.

복사본 생성과 직접 수정 사이의 장단점을 고려해보는 것도 좋은 경험이었다.
