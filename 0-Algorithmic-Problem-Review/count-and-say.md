## [**Count and Say**](https://leetcode.com/problems/count-and-say/)

`countAndSay` 문제는 주어진 숫자 `n`에 대해 특정 패턴을 따르는 문자열을 생성하는 문제이다.

문제의 핵심은, 이전 숫자 문자열을 "읽고 말하는" 방식을 반복하여 `n`번째 문자열을 생성하는 것이다.

## 주요 포인트

1. `n = 1`일 때, 시작 문자열은 `"1"`이다.
2. 문자열을 "읽고 말하기" 방식으로 변환한다. 예를 들어, `"1"`은 `"11"`, `"11"`은 `"21"`처럼 변환된다.
3. 주어진 숫자 `n`에 대해, 이전 문자열을 기반으로 새로운 문자열을 계속해서 생성한다.
4. `n`번째 문자열을 구하고 반환하는 것이 목표이다.

## 나의 코드

```tsx
var countAndSay = function(n) {
  let seq = "1";

  function next(seq) {
    let result = "";
    let count = 1;

    for (let i = 1; i < seq.length; i++) {
      if (seq[i - 1] === seq[i]) {
        count++;
      } else {
        result += count + seq[i - 1];
        count = 1;
      }
    }

    result += count + seq[seq.length - 1];

    return result;
  }

  for (let i = 1; i < n; i++) {
    seq = next(seq);
  }

  return seq;
};
```

## 나의 수도 코드

1. 변수 `seq`를 `"1"`로 초기화.
2. 함수 `next(seq)`를 정의.
3. 빈 문자열 `result`와 카운트 `count = 1`을 설정.
4. 주어진 `seq`를 순회하며, 연속된 숫자의 개수를 구함.
    - 연속된 숫자가 끝나면 `result`에 `"count + 숫자"`를 추가하고 카운트를 초기화.
5. 루프 종료 후 마지막 숫자를 `result`에 추가.
6. 매 반복마다 `next(seq)`를 호출하여 `seq`를 업데이트합니다.
7. 최종적으로 생성된 `seq`를 반환.

## 시간 복잡도

- 수열의 길이는 매번 기하급수적으로 증가.

**`next` 함수**는 각 단계에서 수열의 길이만큼 순회하므로, 전체 시간복잡도는 O(2^n).

## 공간 복잡도

- 각 단계에서 새로운 수열을 저장하므로, 최대 수열 길이에 비례한 공간이 필요하다.

따라서, 공간복잡도는 O(2^n)이다.

## 알아둬야 할 것!

1. **재귀와 반복 구조의 이해**
    - `n`번의 반복을 통해 점진적으로 결과를 생성하는 방법.
    - 재귀적 접근과 반복적 접근의 차이와 선택 기준.
2. **기하급수적 증가와 시간복잡도**
    - 결과 수열의 길이가 2n−1로 증가하는 이유와 이로 인한 계산량 분석.
    - 지수적 증가가 포함된 알고리즘의 한계와 효율화 방안.
3. 이미 계산된 값을 저장하고 재사용하여 중복 계산 방지.

## 회고

이번 문제를 풀면서 문자열 처리와 수열 생성에 대한 알고리즘적 사고를 깊이 이해할 수 있었다.

특히 "Count and Say"라는 규칙적 수열의 특성을 분석는 패턴 발견의 중요성을 느꼈다.

구현 과정에서 시간복잡도와 공간복잡도의 한계를 인식하고 이를 최적화할 방법들을 고민하게 되었다.

이 문제를 통해 기하급수적 증가의 특성과 이를 다루는 알고리즘 설계 능력을 키우는 계기가 되었다.

앞으로는 효율화와 확장 가능성을 더 고려한 설계를 목표로 삼을 것이다.
