## [**Container With Most Water**](https://leetcode.com/problems/container-with-most-water/)

이 문제는 주어진 배열에서 두 개의 선을 선택해 x축과 함께 물을 담을 수 있는 최대 용량의 컨테이너를 만들고, 그 용량을 구하는 문제이다.

## 주요 포인트

1. **넓이 계산**
    - 두 선 사이의 거리는 인덱스 차이로, 높이는 두 선 중 더 작은 값에 의해 결정된다.
    - 넓이 = 거리 * 최소 높이
2. **선은 기울지 않음**
    - 선을 기울일 수 없기 때문에, 두 선의 높이 중 낮은 쪽을 기준으로 넓이를 계산해야 한다.
3. 투 포인터 접근법
    - 시작고 끝에서 두 포인트를 설정하여 가장 큰 넓이를 찾는 효율적인 방법을 찾아야 한다.

## 나의 코드

```
var maxArea = function(height) {
  let max = 0;

  for (let i = 0; i < height.length - 1; i++) {
    for (let j = i + 1; j < height.length; j++) {
    const arr = height.slice(i, j + 1);
      if ((j - i) * Math.min(height[i], height[j]) > max) {
        max = (j - i) * Math.min(height[i], height[j]);
      }
    }
  }
  
  return max;
};
```

## 나의 수도 코드

1. `max`라는 변수를 0으로 초기화하여, 물을 담을 수 있는 최대 넓이를 추적.
2. 배열의 첫 번째 요소부터 마지막 전 요소까지 반복문을 시작.
    - 변수 `i`는 첫 번째 선의 인덱스 역할을 함.
3. `i`의 다음 요소부터 배열의 끝까지 두 번째 반복문 실행.
    - 변수 `j`는 두 번째 선의 인덱스 역할을 함.
4. `height[i]`와 `height[j]` 중 작은 값을 찾고, 인덱스 차이 `j - i`와 곱하여 현재 컨테이너의 넓이 계산.
5. 계산한 넓이가 `max`보다 크면 `max` 업데이트.
6. 두 반복문이 끝나면 `max`를 반환.

이 코드는 모든 가능한 쌍을 검사하기 때문에 시간 복잡도가 O(n^2)이다.

## 다른 사람의 풀이

```
var maxArea = function(height) {
  let max = 0;
  let left = 0;
  let right = height.length - 1;

  while (left < right) {
    let width = right - left;
    let minHeight = Math.min(height[left], height[right]);
    let area = width * minHeight;
    
    max = Math.max(max, area);
    
    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  
  return max;
};
```

## 다른 사람의 수도

1. `max` 변수를 0으로 설정해 최대 넓이를 저장할 준비.
2. `left`는 배열의 시작(첫 번째 인덱스), `right`는 배열의 끝(마지막 인덱스)으로 설정.
3. `left` 포인터가 `right` 포인터보다 작을 때까지 반복.
4. 두 선 사이의 거리는 `right - left`로 계산.
5. 두 선 중 더 작은 높이를 선택해 `minHeight`로 설정.
6. 넓이를 계산: `width * minHeight`.
7. 현재 계산된 넓이가 `max`보다 크면 `max`를 갱신.
8. `height[left]`가 `height[right]`보다 작으면, `left` 포인터를 오른쪽으로 이동.
9. 그렇지 않으면 `right` 포인터를 왼쪽으로 이동.
10. 반복이 끝나면 최대 넓이인 `max`를 반환.

이 방식은 모든 가능한 경우를 다 고려하되, 매번 두 포인터 중 작은 쪽을 이동시키기 때문에 시간 복잡도가 O(n)으로 줄어든다.

## 두 코드의 차이

- **나 코드**
    - 이중 `for` 반복문을 사용하여 모든 가능한 쌍을 탐색하고 각각의 넓이를 계산하는 방식이다.
    - 두 개의 중첩된 반복문으로 인해 시간 복잡도가 **O(n^2)** 입니다. 즉, 배열의 길이가 커질수록 성능이 급격히 저하된다.
- 다른 사람의 **코드**
    - **투 포인터**를 사용하여 양 끝에서 시작해 더 작은 높이를 가진 포인터를 이동시키며 최대 넓이를 계산한다.
    - 모든 경우를 한 번씩만 검사하기 때문에 시간 복잡도가 O(n)으로 훨씬 빠르다.

### 2. **탐색 방식 차이**:

- **나의 코드**
    - 모든 선의 쌍을 계산하려고 한다. 즉, `i`와 `j`가 배열 내의 모든 인덱스 조합을 탐색하며 넓이를 계산한다. 이는 비효율적이며 불필요하게 많은 계산을 발생시킨다.
- 다른 사람의 **코드**
    - 투 포인터 기법을 사용해, 양쪽 끝에서 시작하여 중앙으로 이동한다.
    - 한쪽 포인터를 움직이며 그때마다 넓이를 계산하기 때문에, 효율적으로 탐색을 수행한다.
    - 특히, 매번 더 작은 선을 가진 포인터를 이동시켜 의미 없는 비교를 줄인다.

### 3. **불필요한 메모리 사용**:

- **나의 코드**
    - `height.slice(i, j + 1)`로 배열의 일부를 자르는 작업을 하지만, 이는 넓이 계산에 불필요하다.
    - 자른 배열을 사용할 필요 없이 바로 `height[i]`와 `height[j]` 값을 사용하면 된다.
- 다른 사람의 **코드**
    - 배열의 일부를 자르지 않고 바로 `height[left]`와 `height[right]`로 비교한다.
    - 메모리와 연산 자원을 덜 소모하는 방식이다.

### 4. **포인터 이동 전략**:

- **나의 코드**
    - 모든 인덱스 조합을 다 따져보는 brute-force 방식이라 포인터 이동 전략이 없다.
- 다른 사람의 **코드**
    - 두 선 중 더 작은 선을 기준으로 포인터를 이동시킨다.
    - 이렇게 하면 남은 부분에서 더 큰 높이를 가진 선을 찾을 수 있게 되어 넓이를 최대화할 가능성이 높아진다.

## 알아둬야 할 것!

### 1. **투 포인터 기법의 효율성**

- **투 포인터**는 배열에서 두 개의 포인터를 설정하여 효율적으로 탐색을 할 수 있는 기법이다.
- 이 문제에서는 두 선을 선택해 최대 넓이를 계산하는 데 유용하게 사용된다.
- 투 포인터 기법은 반복적으로 선의 양 끝에서 시작해 작은 쪽을 이동시키며 문제를 해결한다.

### 2. **높이가 작은 쪽을 이동시키는 이유**:

- 컨테이너의 넓이는 선 사이의 거리와 두 선 중 더 작은 높이에 의해 결정된다.
- 두 선 중 하나를 이동시킬 때, 더 작은 높이를 가진 선을 이동시키는 것이 합리적이다.
- 작은 높이를 이동시키면 더 높은 선을 만날 가능성이 있고, 그로 인해 넓이를 더 크게 만들 수 있다.
- 반대로 큰 높이를 이동시키면 넓이가 줄어들거나 그대로일 가능성이 높다.

## 회고

이번 "Container With Most Water" 문제를 해결하면서 **투 포인터 기법의 효율성**을 다시금 실감했다. 처음에는 brute-force 방식으로 모든 경우를 탐색했서 타임리밋에 걸려 통과하지 못했다.

투 포인터를 도입해 시간 복잡도를 O(n)으로 줄이며 성능을 크게 개선하는 방법을 알았다. 특히, **작은 높이를 가진 선을 이동**시키는 논리가 이 문제에서 핵심이었다.

이러한 최적화 기법을 익힘으로써, 대규모 데이터를 다룰 때 더욱 효율적인 코드 작성을 할 수 있을 것 같다. 앞으로도 알고리즘 최적화에 대한 이해를 꾸준히 높여 나가야겠다.
