## [**Find Champion II**](https://leetcode.com/problems/find-champion-ii/)

주어진 DAG(Directed Acyclic Graph)에서 다른 모든 팀보다 강한 유일한 챔피언 팀을 찾아야 한다.

챔피언은 진입 차수가 0인 노드이며, 여러 개거나 없으면 `-1`을 반환한다.

## 주요 포인트

1. **DAG (Directed Acyclic Graph)**
    - 방향성이 있는 비순환 그래프.
    - 노드와 간선으로 구성되며, 특정 노드에서 다른 노드로 가는 방향성이 존재함.
    - 사이클(순환)이 없다는 점이 중요.
2. **진입 차수 (In-degree)**
    - 특정 노드로 들어오는 간선의 개수.
    - 진입 차수가 0인 노드는 다른 노드로부터 영향을 받지 않는 노드.
3. **유일성 판단**
    - 진입 차수가 0인 노드가 단 하나여야만 유일한 챔피언이 될 수 있음.
    - 진입 차수가 0인 노드가 여러 개거나 없으면 챔피언이 존재하지 않음.
4. **그래프 탐색 기법**
    - 그래프의 노드와 간선을 탐색하거나 처리하기 위해 배열이나 객체를 사용하여 데이터를 저장하고 처리하는 방법.
5. **배열 및 맵 초기화**
    - 노드 수만큼 배열이나 객체를 초기화하고, 간선을 처리하면서 데이터를 업데이트하는 방식.

## 나의 코드

```tsx
var findChampion = function(n, edges) {
    const inDegree = Array(n).fill(0);

    for (let [u, v] of edges) {
        inDegree[v]++;
    }

    const potentialChampions = [];
    for (let i = 0; i < n; i++) {
        if (inDegree[i] === 0) {
            potentialChampions.push(i);
        }
    }

    return potentialChampions.length === 1 ? potentialChampions[0] : -1;
};

```

## 나의 수도 코드

1. 크기가 n인 배열 `inDegree`를 0으로 초기화.
    - 이 배열은 각 팀의 진입 차수(자신보다 강한 팀의 수)를 저장.
2. edges 배열의 각 간선 [u, v]에 `inDegree[v]`를 1 증가.
3. 빈 리스트 `potentialChampions`를 초기화.
4. `inDegree[i]`가 0이면
    - 팀 `i`를 `potentialChampions`에 추가.
5. `potentialChampions`의 길이를 확인.
    - 길이가 정확히 1이면`potentialChampions`의 첫 번째 값을 반환.
    - 그렇지 않으면 1을 반환.

## 시간 복잡도

1. **간선 처리**
    - 주어진 `edges` 배열을 순회하면서 각 간선에 대해 진입 차수를 업데이트.
    - 이 작업은 `edges` 배열의 길이, 즉 간선의 수 `m`만큼 반복되므로 **O(m)**.
2. **노드 탐색**
    - 각 노드(팀)의 진입 차수를 확인하고, 진입 차수가 `0`인 노드를 찾는다.
    - 이 작업은 노드의 수 `n`만큼 반복되므로 **O(n)**.

**최종 시간 복잡도**

`O(n + m)`

## 공간 복잡도

1. **진입 차수 배열 (`inDegree`)**
    - 노드의 수 `n`만큼 크기를 가지는 배열을 사용.
    - 따라서 공간 복잡도는 **O(n)**.
2. **잠재적 챔피언 리스트 (`potentialChampions`)**
    - 최대 `n`개의 노드를 저장할 수 있으므로 최악의 경우에도 **O(n)**.

**최종 공간 복잡도**

`O(n)`

## 알아둬야 할 것!

1. **그래프 데이터의 효율적 처리 방법**
    - 노드 및 간선 데이터를 배열 또는 맵으로 표현하여 필요한 값을 빠르게 계산하는 방법.
    - 간선이 많아도 효율적으로 처리 가능한 알고리즘 설계.
2. **문제의 조건을 만족하는 결과 도출 방법**
    - 진입 차수가 0인 노드가 없거나 여러 개인 경우 `1`을 반환하는 조건을 정확히 구현.
    - 결과를 명확히 판단할 수 있는 로직 작성의 중요성.
3. **유일성 확인과 반환 로직**
    - 유일한 챔피언 조건(진입 차수 0이 1개)을 확인하는 방법.
    - 배열을 사용해 조건에 따라 결과를 간단히 반환하는 로직 설계.
4. **그래프 이론을 실제 문제에 응용**
    - DAG의 특성과 그래프 알고리즘을 활용해 현실적인 문제를 해결하는 접근법.
    - 문제의 그래프 표현과 알고리즘 설계가 어떻게 연결되는지 이해.

## 회고

이 문제를 풀면서 그래프에서의 진입 차수와 DAG의 특성을 깊이 이해할 수 있었다.

특히, 진입 차수가 0인 노드가 다른 노드보다 강한 팀이라는 점을 파악하고, 이를 효율적으로 계산하는 방법을 배우는 과정이 흥미로웠다.

문제를 해결하면서 유일한 챔피언을 판별하기 위해 조건 분기를 설계하는 부분이 까다로웠지만, 단계별로 문제를 분리하니 논리적으로 접근할 수 있었다.

간선과 노드를 한 번씩만 순회하여 문제를 해결할 수 있다는 점에서 그래프 탐색의 효율성을 체감했고 앞으로는 다양한 테스트 케이스를 더 면밀히 점검하고, 그래프 알고리즘의 기본기를 더 확실히 다져야겠다.
