## [Rank Transform of an Array](https://leetcode.com/problems/rank-transform-of-an-array/description/?envType=daily-question&envId=2024-10-02)

이 문제는 배열의 각 요소를 해당 요소의 순위(rank)로 변환하는 문제이다.

## 주요 포인트

- 순위는 1부터 시작하는 정수이다.
- 값이 클수록 순위도 큽니다. 두 요소가 같으면 순위도 같아야 한다.
- 순위는 가능한 한 작아야 한다.

## 나의 코드

```tsx
var arrayRankTransform = function (arr) {
    const sortedArr = [...arr].sort((a, b) => a - b);

    const rankMap = new Map();

    let rank = 1;
    for (const num of sortedArr) {
        if (!rankMap.has(num)) {
            rankMap.set(num, rank++);
        }
    }

    return arr.map(num => rankMap.get(num));
};
```

## 나의 수도 코드

1. 원본 배열을 복사하여 오름차순으로 정렬합니다.
2. Map을 생성하여 각 고유 값에 순위를 할당합니다.
3. 정렬된 배열을 순회하면서 처음 보는 숫자에만 새로운 순위를 할당합니다.
4. 마지막으로 원본 배열의 각 요소를 Map에서 찾은 해당 순위로 변환합니다.

## 시간 복잡도

1. 배열 복사
    - `[...arr]` - O(n) 시간이 소요.
2. 정렬
    - `sort((a, b) => a - b)` - JavaScript의 정렬 알고리즘은 O(n log n) 시간이 소요.
3. Map 생성 및 순위 할당
    - 정렬된 배열을 한 번 순회하면서 Map에 값과 순위를 저장함. 이는 O(n) 시간이 소요.
4. 원본 배열 변환
    - `arr.map(num => rankMap.get(num))` - 원본 배열을 한 번 순회하면서 각 요소의 순위를 찾아 변환.
    - Map의 조회는 O(1)이므로, 전체적으로 O(n) 시간이 소요.

전체 시간 복잡도는 가장 느린 부분에 의해 결정되므로 O(n log n).

## 공간 복잡도

1. 정렬된 배열 복사본 : `sortedArr` - 원본 배열의 크기만큼 추가 공간이 필요하므로 O(n).
2. 순위 Map : `rankMap` - 최악의 경우 모든 요소가 고유하다면 원본 배열 크기만큼의 공간이 필요하므로 O(n) .
3. 결과 배열 : `return arr.map(...)` - 원본 배열 크기와 동일한 새 배열을 반환하므로 O(n) .

## 알아둬야 할 것!

- 배열을 정렬함으로써 자연스럽게 값의 크기에 따른 순위를 결정할 수 있다.
- 각 요소의 순위를 Map에 저장함으로써 O(1) 시간에 조회가 가능하다.
- 이미 Map에 있는 값을 만났을 때 새 순위를 할당하지 않음으로써 동일한 값에 동일한 순위를 보장했다.
- 정렬은 복사본에서 수행하고 최종 변환은 원본 배열의 구조를 유지하면서 진행했다.

## 회고

이 문제를 풀면서 정렬과 Map 자료구조의 활용이 핵심이다.

처음에는 단순히 요소들을 정렬하고 인덱스를 사용하려 했으나, 중복 요소에 대한 처리가 필요하다는 점을 알았다.

정렬된 배열에서 고유한 값에만 새 순위를 할당하는 접근법이 효율적이였고 이 방식으로 중복된 값에 대해 동일한 순위를 보장하면서도 원본 배열의 순서를 유지할 수 있었다.
