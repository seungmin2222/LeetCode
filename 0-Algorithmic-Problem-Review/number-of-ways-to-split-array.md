## [**Number of Ways to Split Array**](https://leetcode.com/problems/number-of-ways-to-split-array/)

이문제는 배열 `nums`에서 인덱스 `i`를 기준으로 나눌 때 `왼쪽 부분 합 >= 오른쪽 부분 합`이어야 하고,`i` 오른쪽에 최소 1개의 요소가 있어야 한다.

## 주요 포인트

- **조건 이해**
    - `왼쪽 합 >= 오른쪽 합`이어야 함.
    - 배열을 나누는 기준점 `i`의 오른쪽에 최소 1개의 요소가 있어야 함 (`0 <= i < n-1`).
- **부분 합 계산**
    - `왼쪽 합(leftSum)`과 `전체 합(totalSum)`에서 `rightSum`을 계산하여 비교할 수 있어야 함.
- **효율성**
    - 문제의 배열 크기가 클 경우, 반복적인 계산을 피하기 위해 한 번의 순회로 부분 합을 갱신해야 함.

## 나의 코드

```jsx
var waysToSplitArray = function(nums) {
    const n = nums.length;
    let totalSum = nums.reduce((sum, num) => sum + num, 0);
    let leftSum = 0;
    let count = 0;

    for (let i = 0; i < n - 1; i++) {
        leftSum += nums[i];
        let rightSum = totalSum - leftSum;
        if (leftSum >= rightSum) {
            count++;
        }
    }

    return count;
};
```

## 나의 수도 코드

1. `totalSum`로 전체 배열의 합을 계산.
2. 반복문에서 `leftSum`을 점진적으로 업데이트하며, `rightSum = totalSum - leftSum` 계산.
3. 조건을 만족하면 `count` 증가.
4. 최종적으로 `count` 반환.

## 시간 복잡도

- 배열을 한 번 순회(`reduce`)하여 `totalSum`을 계산 → O(n).
- 다시 배열을 한 번 순회하면서 조건을 확인 → O(n).

따라서 전체 시간 복잡도는 **O(n)**.

## 공간 복잡도

- `totalSum`, `leftSum`, `rightSum`, `count` 등의 상수 크기 변수만 사용.
- 입력 배열 `nums` 외에 추가적인 공간을 사용하지 않음.

따라서 공간 복잡도는 **O(1)**.

## 알아둬야 할 것!

- **효율적인 반복문 활용**
    - 한 번의 순회로 `leftSum`을 갱신하고 `rightSum`을 계산.
    - 이 과정에서 매번 조건을 확인하여 `count`를 업데이트.
- **공간 최적화**
    - 추가적인 배열이나 데이터 구조 없이 변수 몇 개로만 구현.
    - 입력 배열의 크기와 무관하게 공간 사용량이 일정.
- **조건 적용의 범위**
    - 반복문은 `0 <= i < n-1`까지만 순회해야 함. 이 범위를 초과하면 오른쪽에 남은 요소가 없게 됨.
    - 조건 검사를 정확히 이해해야 구현 실수가 줄어듦.
- **테스트 케이스 중요성**
    - 다양한 케이스 (`음수 포함`, `모두 양수`, `배열 크기 작거나 큼`)를 테스트하여 로직 검증 필요.

## 회고

문제의 핵심은 `왼쪽 합 >= 오른쪽 합` 조건과 `n-1` 이전까지만 유효한 나누는 기준을 이해하는 것이었다.

처음엔 모든 경우를 탐색하려 했으나, 전체 합(`totalSum`)과 왼쪽 누적 합(`leftSum`)을 활용해 효율적으로 계산(O(n))했다.

음수 포함 배열에서도 비교가 제대로 동작하도록 조건 처리에 신경 썼다.

시간/공간 복잡도는 최적화되었지만, 다양한 테스트 케이스를 더 작성할 필요성을 느꼈다.

효율적 계산과 조건 기반 문제 해결의 중요성을 다시 깨달았으며, 이를 다른 문제에 적용해야겠다.
