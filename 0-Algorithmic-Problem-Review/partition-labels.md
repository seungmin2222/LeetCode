## [Partition Labels](https://leetcode.com/problems/partition-labels/?envType=daily-question&envId=2025-03-30)

이 문제는 문자열을 나눌 때, 각 문자가 하나의 조각에만 포함되도록 최대한 많이 분할하는 문제이다.

## 주요 포인트

1. 각 문자의 마지막 등장 위치 저장
2. 문자열을 순회하면서 현재 파티션의 범위를 결정
3. 파티션이 완성되었는지 체크

## 나의 코드

```jsx
var partitionLabels = function (s) {
    const lastIndex = {};

    for (let i = 0; i < s.length; i++) {
        lastIndex[s[i]] = i;
    }

    const result = [];
    let start = 0;
    let end = 0;

    for (let i = 0; i < s.length; i++) {
        end = Math.max(end, lastIndex[s[i]]);

        if (i === end) {
            result.push(end - start + 1);
            start = i + 1;
        }
    }

    return result;
};
```

## 나의 수도 코드

1. 각 문자가 문자열에서 마지막으로 등장하는 위치를 기록한다.
2. 현재 인덱스를 기준으로 해당 문자의 마지막 등장 위치까지를 end로 설정한다.
3. 순회하면서 end를 계속 갱신한다.
4. 현재 인덱스가 end에 도달하면 하나의 파티션이 끝난 것으로 판단한다.
5. end - start + 1을 계산해 결과 배열에 추가하고, start를 i + 1로 갱신한다.

## 시간 복잡도

1. 각 문자의 마지막 인덱스를 저장할 때 1번
2. 파티션을 계산할 때 1번

총 시간 복잡도는 O(n)이다.

## 공간 복잡도

1. 상수 크기의 공간만 사용 → O(1).

최종 공간 복잡도는 O(1)이다.

## 알아둬야 할 것!

1. **문자의 마지막 등장 위치 저장** → 각 문자가 어디까지 영향을 미치는지 파악할 수 있음
2. **파티션의 끝을 현재 문자들의 마지막 위치 중 최댓값으로 설정**
3. **현재 인덱스가 파티션의 끝과 같아지면 하나의 조각 완성**
4. **파티션 길이는 end - start + 1로 계산**
5. **알파벳 소문자만 다루므로 공간 복잡도는 O(1)**

## 회고

문제 자체는 간단한 문자열 분할이지만, “문자 하나가 오직 한 파트에만 포함되어야 한다”는 조건이 핵심이었다.

처음엔 모든 문자를 순차적으로 나누면 될 것 같았지만, 같은 문자가 뒤에 또 나오는 경우가 있어서 단순하게 풀 수 없었다.

각 문자의 마지막 위치를 미리 저장해두고, 현재 파티션의 끝을 그 최대값으로 계속 갱신하면서 판단하는 방식이 인상적이었다.

기억해야 할 점은 파티션 경계가 현재 문자의 마지막 위치를 기준으로 정해지는 게 아니라, **현재까지 등장한 모든 문자 중 가장 마지막 위치**로 정해져야 한다는 것.

문제를 푸는 과정에서 “탐욕적 접근”이 깔끔하게 적용될 수 있는 좋은 예제였다.
