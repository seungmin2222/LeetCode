## [**Next Permutation**](https://leetcode.com/problems/next-permutation/)

주어진 배열 `nums`의 숫자 조합을 사전 순으로 다음 순열로 변경하는 문제다.

만약 배열이 마지막 순열에 도달해 있으면, 가장 작은 순열로 바꾼다.

## 주요 포인트

- 숫자의 조합이 사전적으로 나열된 순서를 따르며, 이를 기반으로 다음 순서를 구해야 한다.
- 배열이 내림차순으로 정렬된 경우는 마지막 순열이며, 이를 뒤집으면 가장 작은 순열이 된다.
- **두 값 교환(swap)**: 배열의 두 값을 교환하여 순열의 순서를 변경하는 기술을 알아야 한다.
- **배열 뒤집기**: 부분 배열을 뒤집어서 가장 작은 순열을 만들기 위해 사용하는 과정을 알아야 한다.

## 나의 코드

```jsx
var nextPermutation = function(nums) {
    let i = nums.length - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }

    if (i >= 0) {
        let j = nums.length - 1;
        while (nums[j] <= nums[i]) {
            j--;
        }
        [nums[i], nums[j]] = [nums[j], nums[i]];
    }

    let left = i + 1;
    let right = nums.length - 1;
    while (left < right) {
        [nums[left], nums[right]] = [nums[right], nums[left]];
        left++;
        right--;
    }
};
```

## 나의 수도 코드

1. 시작점으로 배열 끝에서 두 번째 인덱스를 설정 (i = 배열 길이 - 2)
2. 배열이 내림차순인지 확인하기 위해, i가 0 이상이고 nums[i] >= nums[i+1]인 동안 i를 감소시킴
3. 만약 i가 0 이상이면 (즉, 내림차순이 아닌 위치를 찾았으면)
    1. 배열의 끝부터 다시 탐색하며 nums[i]보다 큰 가장 작은 값을 찾기 위해 j를 설정 (j = 배열 길이 - 1)
    2.  nums[i] < nums[j]인 가장 큰 j를 찾아 nums[i]와 nums[j]를 교환
4. i 이후의 배열을 오름차순으로 정렬하기 위해, i+1부터 배열 끝까지를 뒤집음

## 알아둬야 할 것!

- **사전순 순열(Permutation Order)**
    - 주어진 배열을 가능한 모든 순열 중 사전 순서로 나열했을 때, 다음 순서를 찾는 개념이다.
    - 예를 들어, 배열 `[1, 2, 3]`의 다음 순열은 `[1, 3, 2]`입니다. 마지막 순열은 `[3, 2, 1]`로 사전순의 마지막이다.
- **배열 내림차순 (Descending Order)**
    - 배열이 내림차순일 경우, 이는 가능한 가장 큰 순열을 의미한다.
    - 이때는 배열을 뒤집어 가장 작은 순열로 바꿔줘야 한다.
- **배열 뒤집기 (Reverse Array)**
    - 배열의 일부분을 뒤집는 기술은 다음 순열을 만들 때 자주 사용된다.
    - 특히 순열이 내림차순으로 되어 있을 때, 뒤집어서 오름차순으로 만들어야 한다.
- **교환(Swap)**
    - 두 숫자를 교환하는 것은 순열을 변경하는 기본적인 방법이다.
    - 주어진 숫자 배열에서 사전 순서로 다음에 오는 순열을 만들기 위해, 배열 내에서 특정 위치의 숫자를 교환해야 한다.
- **문제 해결 순서**
    - 배열의 뒤에서부터 시작하여 처음으로 감소하는 부분을 찾고,
    - 그 부분을 다음 큰 값과 교환하며,
    - 이후 그 뒷부분을 오름차순으로 정렬하는 방식이다.

## 회고

문제를 푸는 데 있어 처음 감소하는 부분을 찾는 과정에서 실수를 줄이고 정확성을 높이기 위해 더 많은 연습이 필요한 것 같다.

또한, 문제를 조금 더 효율적으로 풀 수 있는 방법에 대해 고민해볼 필요가 있다.

@return {void} Do not return anything, modify nums in-place instead.

- 이 함수는 배열 `nums`를 직접 수정하며, 수정된 결과를 별도로 반환하지 않는다.
- 함수 호출 후, `nums` 배열 자체가 변경되어 있는 상태입니다. 이를 **in-place** 수정이라고 한다.

```jsx
// 예시
let arr = [1, 2, 3];

nextPermutation(arr);
// 함수 호출 후 arr 배열이 직접 변경됨 (예: [1, 3, 2] 등)
```
