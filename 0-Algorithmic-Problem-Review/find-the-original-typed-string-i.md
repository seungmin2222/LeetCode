## [Find the Original Typed String I](https://leetcode.com/problems/find-the-original-typed-string-i/?envType=daily-question&envId=2025-07-01)

동일한 문자가 연속으로 등장하는 부분을 찾아서, 그 중 하나의 문자를 제거한 문자열들을 후보로 추가해야 한다.

최대 한 번만 중복된 키 입력이 있다고 했으므로, 중복된 문자 그룹 중 하나만 줄여보면 되는 문제이다.

## 주요 포인트

- 실수는 한 번만 발생 가능
    
    → 여러 문자를 중복해서 입력한 경우가 있어도, 실제 실수는 그중 하나만 발생했을 수 있다.
    
- 중복된 문자 그룹을 하나씩 선택해서 하나 이상의 문자를 줄인 경우들이 모두 유효한 후보이다.
- 반복 그룹 하나당 (길이 - 1) 만큼 줄일 수 있으며,
    
    실수 없이 정확하게 입력했을 수도 있으므로 **원래 문자열도 포함**해야 한다.
    
- Set 자료구조를 이용해 중복을 제거하고 가능한 모든 원래 문자열을 저장할 수 있다.

## 나의 코드

```jsx
var possibleStringCount = function(word) {
    const seen = new Set();
    seen.add(word); 

    const n = word.length;
    let i = 0;

    while (i < n) {
        let j = i;
        while (j < n && word[j] === word[i]) {
            j++;
        }

        const len = j - i;

        for (let cut = 1; cut < len; cut++) {
            const newWord = word.slice(0, i) + word.slice(i, j - cut) + word.slice(j);
            seen.add(newWord);
        }

        i = j;
    }

    return seen.size;
};
```

## 나의 수도 코드

1. 가능한 문자열을 저장할 Set을 만들고, word 자체를 먼저 넣는다
2. 문자열을 순회하면서 중복된 문자 그룹을 찾는다
3. 각 그룹에서 문자를 1개 이상 줄인 경우들을 만들어 Set에 추가한다
4. 마지막에 Set의 크기를 반환한다

## 시간 복잡도

- O(n²)
    
    최악의 경우, 모든 문자가 같아서 (길이 n짜리 그룹) O(n)개의 후보가 생기고, 각 후보 생성 시 slice가 O(n) 소요됨.
    

## 공간 복잡도

- O(n²)
    
    중복 제거를 위해 생성된 모든 문자열을 Set에 저장하기 때문.
    

## 알아둬야 할 것!

- "실수가 최대 한 번"이라는 조건은
    - 여러 그룹을 동시에 줄이는 것이 **허용되지 않는다**는 의미
    - 반대로, **모든 중복 그룹 각각을 한 번씩 줄여보는 시도는 유효**하다
- 문자열 처리에서 slice와 Set을 활용한 중복 제거 방식은 매우 유용하다

## 회고

처음엔 가장 긴 반복 문자 그룹만 줄이는 방식으로 접근했지만,
문제 조건을 다시 읽고 “모든 반복 그룹 중 하나만 줄인 경우들을 모두 포함”해야 한다는 점을 깨달았다.

문제 조건을 정확히 해석하는 것이 얼마나 중요한지를 다시 느꼈다.
앞으로도 "최대 한 번", "하나만 가능" 같은 제한 조건은 아주 신중하게 다뤄야겠다.
