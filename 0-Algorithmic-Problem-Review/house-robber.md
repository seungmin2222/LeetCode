## [**House Robber**](https://leetcode.com/problems/house-robber/)

이 문제는 길게 늘어선 집들에서 인접한 두 집을 동시에 털 수 없는 조건 하에, 각 집에 있는 금액을 최대한으로 뺏기 위한 최적의 전략을 찾는 것이다.

## 주요 포인트

1. 인접한 집을 동시에 털 수 없기 때문에, 각 집을 선택할 때 이전 집과의 관계를 고려해야 한다.
2. 문제를 하위 문제로 나누어 이전 집들의 최대 금액을 계산하고, 이를 기반으로 현재 집의 최대 금액을 결정하는 방식으로 접근한다.
3. `dp[i]`는 `i`번째 집까지의 최대 금액을 의미하며, 이는 두 가지 경우 (`i`번째 집을 rob하거나 rob하지 않는 경우)에 따라 결정된다.
4. 배열의 크기가 0, 1, 2인 경우를 별도로 처리하여 기본적인 상황을 고려해야 한다.

## 나의 코드

```jsx
var rob = function(nums) {
    const n = nums.length;

    if (n === 0) return 0;
    if (n === 1) return nums[0];
    if (n === 2) return Math.max(nums[0], nums[1]);

    const dp = new Array(n).fill(0);
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);

    for (let i = 2; i < n; i++) {
        dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]);
    }

    return dp[n - 1];
};
```

## 나의 수도 코드

1. 주어진 `nums` 배열의 길이를 계산하고, 예외 상황(빈 배열, 하나 또는 두 개의 집)을 처리.
2. `dp` 배열을 초기화하여 각 집까지의 최대 금액을 저장.
3. 첫 번째 집과 두 번째 집의 최대 금액을 각각 설정.
4. `for` 루프를 사용하여 2번째 집부터 시작해 각 집에 대해 최대 금액을 업데이트.
5. 현재 집을 rob하는 경우와 rob하지 않는 경우를 비교하여 더 큰 값을 선택.
6. 마지막 집의 최대 금액을 반환.

## 다른 사람의 풀이

```jsx
var rob = function(nums) {
    const n = nums.length;

    if (n === 0) return 0;
    if (n === 1) return nums[0];
    if (n === 2) return Math.max(nums[0], nums[1]);

    let prev1 = nums[0];
    let prev2 = Math.max(nums[0], nums[1]);

    for (let i = 2; i < n; i++) {
        const current = Math.max(prev2, nums[i] + prev1);
        prev1 = prev2;
        prev2 = current;
    }

    return prev2;
};
```

## 다른 사람의 수도 코드

1. 주어진 `nums` 배열의 길이를 계산하고, 예외 상황(빈 배열, 하나 또는 두 개의 집)을 처리.
2. 두 개의 변수 `prev1`과 `prev2`를 사용하여 각 집까지의 최대 금액을 추적.
    - `prev1`은 두 번째 마지막 집까지의 최대 금액.
    - `prev2`는 마지막 집까지의 최대 금액.
3. 2번째 집부터 시작하여 각 집에 대해 최대 금액을 업데이트.
    - 현재 집을 rob하는 경우와 rob하지 않는 경우를 비교하여 더 큰 값을 선택.
4. 마지막으로 업데이트된 `prev2`를 반환하여 최대 금액을 제공.

## 알아둬야 할 것!

- **나의 코드 (DP)**
    - `dp` 배열을 사용하여 각 집까지의 최대 금액을 저장.
    - `dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2])`를 통해 각 집에 대한 최적의 선택을 저장.
- **다른 사람의 코드**
    - 두 개의 변수 `prev1`과 `prev2`만 사용하여 이전 집들의 최대 금액을 저장.
    - `current = Math.max(prev2, nums[i] + prev1)`를 통해 현재 집에 대한 최적의 선택을 계산.

---

- **나의 코드 (DP)**
    - 동적 계획법을 구현하는 전통적인 방식으로 이해하기 쉽지만, 배열을 사용하는 만큼 메모리를 더 많이 소모함.
- **다른 사람의 코드**
    - 공간 효율성이 뛰어나며, 필요할 때마다 이전 두 집의 값을 사용하여 현재 집의 최대 금액을 계산.
    - 메모리를 절약할 수 있어, 큰 입력을 처리할 때 더 유리함.

## 회고

이번 문제를 통해 동적 계획법의 중요한 개념과 효율적인 알고리즘 구현의 필요성을 다시 한번 깨달았다.

 인접한 집들을 털 수 없는 제약 조건을 고려하면서, 어떻게 최적의 선택을 할 수 있는지를 고민하며 여러 접근 방식을 시도해보는 과정이 흥미로웠다.

특히, 메모리 사용을 최적화하기 위해 두 개의 변수를 활용한 코드 구현은 실용성과 효율성을 동시에 고려해야 한다는 교훈을 주었다.

앞으로도 다양한 문제를 풀며 이러한 전략들을 더 발전시켜 나가고 싶다.
