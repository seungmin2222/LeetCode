## [**Merge Nodes in Between Zeros**](https://leetcode.com/problems/merge-nodes-in-between-zeros/)

주어진 연결 리스트에서 0으로 구분된 노드들 사이의 값을 합산하여 새로운 노드로 구성된 리스트를 생성하고, 이 새로운 리스트의 헤드를 반환하는 문제이다.

## 주요 포인트

- **연결 리스트의 기본 이해**
    - 연결 리스트의 구조와 각 노드가 어떻게 연결되는지에 대한 기본 개념.
- **노드 탐색 방법**
    - `head` 포인터를 사용하여 리스트를 순회하는 방법과 종료 조건 설정.
- **조건문 활용**
    - 특정 조건(예: 0 값 확인)에 따라 동작을 다르게 처리하는 방법.
- **노드 생성 및 연결**
    - 새 노드를 생성하고 기존 노드와 연결하는 방법.
- **합계 계산**
    - 여러 노드의 값을 누적하여 합산하는 기초적인 산술 연산.

## 나의 코드

```jsx
var mergeNodes = function(head) {
  const dummy = new ListNode(0); 
  let current = dummy;
  let sum = 0;

  head = head.next; 

  while (head) {
    if (head.val === 0) {
      if (sum > 0) {
        current.next = new ListNode(sum);
        current = current.next;
        sum = 0;
      }
    } else {
      sum += head.val;
    }
    head = head.next;
  }

  return dummy.next; 
};
```

## 나의 수도 코드

1. **초기화**
    - `dummy` 노드를 생성하여 값을 0으로 설정.
    - `current` 포인터를 `dummy`로 설정.
    - `sum`을 0으로 초기화.
2. **리스트 순회**
    - `head`가 null이 아닐 때까지 반복.
        - 만약 `head.val`이 0이라면
            - `sum`이 0보다 클 경우
                1. 새로운 `ListNode`를 `sum`으로 생성하여 `current.next`에 연결.
                2. `current`를 새 노드로 이동.
                3. `sum`을 0으로 초기화.
        - **0이 아닌 경우**
            - `sum`에 `head.val`을 더함.
        - **다음 노드로 이동**
            - `head`를 `head.next`로 설정.
3. **결과 반환**
    - `dummy.next`를 반환하여 새로운 리스트의 헤드를 반환.

## 알아둬야 할 것!

1. **더미 노드 사용**
    - 새로운 연결 리스트를 구성할 때 더미 노드를 사용하여 편리하게 노드를 추가하는 패턴.
2. **중첩 조건문 이해**
    - 특정 상황에서만 동작하도록 조건문을 구성하는 기법 (예: 합계가 0보다 클 때만 노드 추가).
3. **시작과 끝의 처리**
    - 입력 리스트의 시작(첫 0)과 끝(마지막 0)에서의 노드 처리 방식 이해.
4. **시간 복잡도와 공간 복잡**
    - O(n) 시간 복잡도 및 O(1) 공간 복잡도와 같은 알고리즘 성능에 대한 기본 개념.
5. **리스트의 변형 및 반환**
    - 원본 리스트를 변형하지 않고 새로운 리스트를 생성하고 반환하는 방식.

## 회고

이번 문제를 통해 연결 리스트의 구조와 0으로 구분된 구간의 값을 합산하는 방식에 대해 깊이 이해했다.

더미 노드를 활용하여 새로운 리스트를 간편하게 생성하는 방법을 익혔고, 조건문을 통해 합계를 관리하는 기법을 배웠다.

앞으로 연결 리스트와 관련된 문제를 더 많이 연습하여 데이터 구조에 대한 이해도를 높일 계획이다. 이러한 경험이 향후 문제 해결에 큰 도움이 될 것으로 예상된다.
