## [**Max Area of Island**](https://leetcode.com/problems/max-area-of-island/description/)

이 문제는 주어진 m x n 크기의 이진 행렬 `grid`에서 섬(island)의 최대 크기를 구하는 문제이다.

## 주요 포인트

1. **섬의 정의** : 섬은 1로 이루어진 그룹으로, 각 1은 상, 하, 좌, 우로 연결될 수 있다.
2. **섬의 크기** : 섬의 크기는 그 섬을 이루는 1의 개수다.
3. **목표** : 주어진 `grid`에서 가장 큰 섬의 크기를 구하는 것입니다. 만약 섬이 하나도 없다면, 0을 반환해야 한다.

## 나의 코드

```jsx
var maxAreaOfIsland = function(grid) {
    let maxNum = 0;

    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[i].length; j++) {
            if (grid[i][j]) {
                const islandArea = checkIsland(i,j);
                
                if (maxNum < islandArea) {
                    maxNum = islandArea;
                }
            }
        }
    }

    function checkIsland (x, y) {
        if (grid[x] && grid[x][y]) {
            let area = 1;
            
            grid[x][y] = 0;

            area += checkIsland(x - 1, y);
            area += checkIsland(x + 1, y);
            area += checkIsland(x, y - 1);
            area += checkIsland(x, y + 1);

            return area;
        } else {
            return 0;
        }

    }

    return maxNum;
};  
```

## 나의 수도 코드

1. **`maxAreaOfIsland` 함수**
    - `grid`에서 각 섬을 찾아서 가장 큰 섬의 면적을 구하는 함수.
2. **이중 for문**
    - 모든 셀을 순차적으로 돌면서, 1인 셀(섬)을 발견하면 `checkIsland` 함수 호출.
3. **`checkIsland` 함수**
    - 주어진 위치에서 상하좌우로 연결된 1을 찾아서 섬 면적을 계산.
    - 이미 방문한 셀은 0으로 바꿔서 다시 방문하지 않도록 처리.
4. **최대 면적 구하기**
    - 섬 면적을 계속 업데이트하면서 가장 큰 섬의 면적을 구함.
5. **결과 반환**
    - 최종적으로 가장 큰 섬의 면적을 반환.

## 시간 복잡도

1. **중첩된 for문**
    - `grid`의 크기를 m x n이라고 할 때, 두 개의 중첩된 for문을 통해 모든 셀을 한 번씩 확인한다.
    - 각 셀에 대해 한 번의 DFS를 호출할 수 있다.
    - 외부 루프는 `m`번 반복하고, 내부 루프는 `n`번 반복하므로 시간 복잡도는 O(m * n)이다.
2. **DFS 호출** 
    - DFS는 하나의 섬을 찾을 때마다 해당 섬의 모든 셀을 방문한다.
    - 섬이 `S` 크기일 때, DFS의 시간 복잡도는 O(S)이다.
    - 그런데, 그리드의 모든 셀을 최대 한 번만 방문하므로 전체 시간 복잡도는 O(m * n)이다.

전체 시간 복잡도는 `O(m * n`)이다.

## 공간 복잡도

1. **기본적인 변수 공간**
    - `maxNum`과 `islandArea` 변수들은 상수 공간을 사용하므로 공간 복잡도에 큰 영향을 미치지 않는다.
2. **재귀 호출 스택 공간**
    - DFS 함수는 재귀적으로 호출되며, 최악의 경우에는 한 섬이 그리드의 모든 셀을 차지할 수 있다.
    - 즉, 재귀 호출 스택의 깊이는 섬의 크기와 동일하므로, 최악의 경우 공간 복잡도는 O(m * n)이 될 수 있다.

전체 공간 복잡도는 `O(m * n)`이다.

## 알아둬야 할 것!

1. **DFS(깊이 우선 탐색)**
    - 한 노드에서 시작해 가능한 깊이까지 탐색을 진행한 후, 더 이상 갈 곳이 없으면 이전 노드로 돌아가 다른 경로를 탐색하는 방식이다.
    - 재귀적으로 구현되며, 여기서는 섬의 각 영역을 탐색하는 데 사용된다.
2. **배열 탐색**
    - 2차원 배열에서 상하좌우 방향으로 인접한 셀들을 탐색하는 방법을 익혀야 한다.
    - 이는 문제에서 연결된 섬을 탐색할 때 필요하다.
3. **변경 및 방문 처리**
    - 이미 방문한 셀은 다시 방문하지 않도록 상태를 변경(여기서는 0으로 설정)하여 효율적인 탐색을 수행해야 한다.

## 회고

이 문제를 풀면서 DFS를 활용한 섬 탐색 방식을 잘 이해할 수 있었다.

처음에는 섬을 어떻게 탐색할지 고민했지만, 재귀를 사용해 상하좌우를 차례로 탐색하는 방식이 효과적이었다.

또한, 중복 계산을 피하기 위해 방문한 셀을 0으로 변경하는 방법을 사용하면서 메모리 효율을 높일 수 있었다.

코드가 길어지지 않도록 최대한 간단하게 구현하려고 했고, 그렇게 해서 성능도 잘 나왔다.

하지만 처음에는 복잡한 문제처럼 느껴졌는데, 문제의 핵심은 단순히 연결된 1을 찾아서 면적을 계산하는 것이었음을 깨달았다.
