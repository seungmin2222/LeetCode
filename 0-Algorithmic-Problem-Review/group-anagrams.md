## [**Group Anagrams**](https://leetcode.com/problems/group-anagrams)

이 문제는 주어진 문자열 배열에서, **아나그램**인 문자열들을 그룹으로 묶어서 반환하는 문제이다.

## 주요 포인트

- **아나그램**
    - 두 문자열이 같은 문자를 같은 빈도로 포함하지만, 문자의 순서는 다를 수 있는 경우이다.
- **정렬을 통한 비교**
    - 문자열을 아나그램인지 확인하는 일반적인 방법은 각 문자열을 알파벳 순서대로 정렬한 후 그 결과를 비교하는 것이다.

## 나의 코드

```jsx
var groupAnagrams = function(strs) {
  const wordObj = {};
  
   for (let i = 0; i < strs.length; i++) {
    const sortWord = strs[i].split("").sort().join("");
    
    if (!wordObj[sortWord]) {
      wordObj[sortWord] = [strs[i]];
    } else {
      wordObj[sortWord].push(strs[i]);
    }
  }
  
 return Object.values(wordObj);
};
```

## 나의 수도 코드

1. **입력값 확인**: 문자열 배열 `strs`가 비어 있는지 확인.
    - 만약 비어 있으면 `[[""]]` 반환.
2. 아나그램을 그룹화하기 위해 빈 오브젝트를 생성.
3. **각 문자열을 반복**
    - 각 문자열을 알파벳 순서로 정렬한 `sortWord`를 생성.
    - 정렬된 문자열 `sortWord`가 해시맵에 존재하는지 확인.
        - 존재하지 않으면, 해당 정렬된 문자열을 키로 하고 원본 문자열을 값으로 배열에 넣어 저장.
        - 이미 존재하면, 해당 키에 해당하는 배열에 현재 문자열을 추가.
4. 최종 그룹을 담을 빈 배열 생성.
5. 해시맵에 저장된 각 키의 값을 배열로 변환해 `arr`에 추가.
6. 그룹화된 아나그램들의 배열을 반환.

## 다른 사람의 풀이

```jsx
var groupAnagrams = function(strs) {
    let ans = {};

    for (let s of strs) {
        let count = new Array(26).fill(0);

        for (let c of s) {
            count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }

        let key = count.join('#'); 
        if (!ans[key]) {
            ans[key] = [];
        }
        ans[key].push(s);
    }

    return Object.values(ans);
};
```

## 다른 사람의 수도 코드

1. 빈 해시맵 `ans`를 초기화.
2. 알파벳 26개의 빈도 배열 `count`를 생성(초기값은 0).
3. `count` 배열에서 `c`에 해당하는 인덱스를 증가.
4. 빈도 배열 `count`를 `'#'`로 연결하여 고유한 키 `key`를 만듬.
5. 해시맵 `ans`에서 `key`가 없으면
    - 빈 배열을 할당.
6. 해당 배열에 문자열 `s`를 추가.
7. `ans`의 값들을 배열로 반환.

## 나의 코드 차이점

### 1. **키 생성 방식**

- **니의 코드**: 문자열을 **정렬**한 후, 그 정렬된 문자열을 해시맵의 키로 사용한다.
    
    ```jsx
    const sortWord = strs[i].split("").sort().join("");
    ```
    
    - 각 문자열을 **알파벳 순으로 정렬**하여 아나그램끼리 동일한 키를 가지게 만든다.

- **다른 사람의 코드**: 각 문자열의 **문자 빈도**를 기반으로 키를 생성한다.
    
    ```jsx
    let count = new Array(26).fill(0);
    
    for (let c of s) {
        count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
    }
    
    let key = count.join('#');
    ```
    
    - 각 문자열에서 각 문자의 빈도를 기록하는 배열을 만들어, 그 배열을 해시맵의 키로 사용한다.

### **2. 가독성 및 구현 난이도**

- **나의 코드**
    - 문자열을 정렬하여 키를 만드는 방식은 **직관적**이고 이해하기 쉬운 방식이다.
    - 정렬 후 동일한 문자열로 아나그램을 그룹화하는 방식은 많이 사용하는 기법이다.
- **다른 사람의 코드**
    - 문자의 빈도를 카운트하고 그 결과를 문자열로 변환하여 키로 사용하는 방식은 **약간 더 복잡하**다.
    - 각 문자의 빈도를 기록해야 하기 때문에 구현이 조금 더 까다롭습니다.

## 알아둬야 할 것!

### **Object.values() 메서드**

- `Object.values()`는 **객체의 값들만 배열로 반환**하는 자바스크립트 메서드이다.
- 객체가 `{"aet": ["eat", "tea", "ate"], "ant": ["tan", "nat"]}`일 때, `Object.values()`를 사용하면 `[["eat", "tea", "ate"], ["tan", "nat"]]`와 같이 객체의 값들만 배열로 추출할 수 있다.
- 이 문제에서 객체에 저장된 아나그램 그룹들을 배열로 반환하는 데 사용했다.

## 회고

이번 문제에서는 **`wordObj[sortWord] = [strs[i]];`** 부분에서 객체의 특정 키에 바로 배열을 할당하는 개념을 사용했다. 이를 통해, **정렬된 문자열을 키로 사용해 아나그램 그룹**을 빠르게 저장할 수 있었다. 

`Object.values(wordObj)`를 사용하여 객체의 값들만 배열로 추출하는 방식도 처음 사용해 보았다.

이 방식은 해시맵에서 저장된 값들을 깔끔하게 모아 반환하는 데 유용하며, 코드를 간결하게 만드는 데 큰 도움이 되었다. 이를 통해 **객체 활용 및 값 추출**에 대한 이해를 깊이 할 수 있었다.
