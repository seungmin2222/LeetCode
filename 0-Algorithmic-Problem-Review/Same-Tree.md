# [Same Tree](https://leetcode.com/problems/same-tree/submissions/)

이 문제는 두 개의 이진 트리가 동일한지 확인하는 함수를 작성하는 문제이다.

## 주요 포인트

1. 두 트리의 구조가 동일해야 한다.
2. 각 노드의 값이 같아야 한다.

## 나의 코드

```jsx
var isSameTree = function(p, q) {
  if (p === null && q === null) {
    return true;
  } 
  
  if (p === null || q === null) {
    return false;
  }
  
  if (p.val !== q.val) {
    return false;
  }
  
  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
};
```

## 나의 수도코드

1. 만약 p와 q가 모두 null이면
    - true 반환 (두 트리가 모두 비어있으므로 동일하다)
2. 만약 p 또는 q 중 하나만 null이면
    - false 반환 (한 트리만 비어있으므로 동일하지 않다)
3. 만약 p.val이 q.val과 다르면
    - false 반환 (현재 노드의 값이 다르므로 동일하지 않다)
4. 반환
    - isSameTree(p.left, q.left)의 결과와
    - isSameTree(p.right, q.right)의 결과를
    - AND 연산하여 반환 (왼쪽 서브트리와 오른쪽 서브트리가 모두 동일해야 함)

## 알아둬야 할 것!

1. 재귀적 접근
    - 이진 트리 문제를 해결할 때 재귀는 매우 효과적인 방법이다.
    - 각 노드에서 동일한 로직을 반복적으로 적용할 수 있다.
2. 기저 조건(Base case) 처리
    - null 체크는 재귀의 종료 조건으로 중요하다.
    - 두 노드가 모두 null일 때와 하나만 null일 때를 구분해야 한다.
3. 단계적 비교
    - 노드의 값을 먼저 비교한 후, 구조를 비교한다.
    - 이는 불필요한 재귀 호출을 줄여 효율성을 높다.
4. 논리 연산자 활
    - AND(&&) 연산자를 사용해 왼쪽과 오른쪽 서브트리의 동일성을 한 번에 확인한다.
5. 트리의 구조적 특성
    - 이진 트리의 각 노드는 왼쪽과 오른쪽 자식을 가질 수 있다.
    - 이 구조를 활용해 재귀적으로 비교한다.
6. 시간 복잡도
    - 이 방법은 O(min(n,m))의 시간 복잡도를 가집니다. 여기서 n과 m은 각 트리의 노드 수다.
7. 공간 복잡도
    - 최악의 경우 O(h)의 공간 복잡도를 가집니다. 여기서 h는 트리의 높이다.

## 중요한 알고리즘 개념

1. DFS (Depth-First Search)
    - 이 알고리즘은 트리나 그래프의 모든 노드를 방문할 때, 가능한 한 깊이 내려가면서 탐색하는 방식이다.
    - 여기서는 재귀를 통해 구현되었다. 각 노드에서 왼쪽 자식으로 깊이 들어간 후, 오른쪽 자식으로 들어간다.
2. 왜 DFS인가?
    - 트리의 루트에서 시작해 왼쪽 자식, 그 다음 오른쪽 자식으로 재귀적으로 호출하며 트리의 끝까지 탐색한다.
    - 한 경로를 끝까지 탐색한 후 백트래킹하여 다른 경로를 탐색한다.
3. DFS vs BFS
    - BFS(Breadth-First Search, 너비 우선 탐색)와 달리, DFS는 스택(여기서는 재귀 호출 스택)을 사용한다.
    - 이 문제에서는 DFS가 더 자연스럽고 간단한 구현을 제공한다.
4. 재귀적 DFS의 특징
    - 코드가 간결하고 이해하기 쉽다.
    - 트리의 구조를 자연스럽게 따라간다.
5. 시간 및 공간 복잡도
    - 시간 복잡도: O(min(n,m)) - 두 트리의 모든 노드를 한 번씩 방문한다.
    - 공간 복잡도: O(h), h는 트리의 높이 - 재귀 호출 스택의 최대 깊이다.
6. DFS와 BFS의 주요 차이점
    - 탐색 순서
        - DFS는 한 경로를 끝까지 탐색한 후 다음 경로로 넘어간다.
        - BFS는 현재 레벨의 모든 노드를 탐색한 후 다음 레벨로 이동한다.
        - 예: 트리에서 DFS는 루트부터 리프까지 수직으로, BFS는 레벨별로 수평으로 탐색한다.
    - 구현 방식
        - DFS는 주로 스택이나 재귀를 사용한다. 재귀 호출은 내부적으로 스택을 사용한다.
        - BFS는 주로 큐를 사용한다. 현재 레벨의 노드들을 큐에 넣고 순서대로 처리한다.
        - 이진 트리 문제에서는 DFS의 재귀적 구현이 코드를 더 간결하게 만든다.
    - 메모리 사용
        - DFS는 현재 경로의 노드들만 메모리에 유지하므로 일반적으로 메모리 사용량이 적다.
        - BFS는 한 레벨의 모든 노드를 저장해야 하므로 넓은 트리에서는 많은 메모리를 사용할 수 있다.
        - 하지만 깊이가 매우 깊은 트리에서는 DFS의 재귀 호출로 인해 스택 오버플로우가 발생할 수 있다.
    - 최단 경로: BFS는 최단 경로 찾기에 유리하지만, DFS는 그렇지 않다.
        - BFS는 레벨 순서로 탐색하므로 최단 경로를 찾는 데 유리하다.
        - DFS는 첫 번째로 찾은 경로가 최단 경로가 아닐 수 있어, 최단 경로 탐색에는 적합하지 않다.
        - 그래프에서 두 노드 간의 최단 거리를 찾을 때는 BFS가 더 효율적이다.
    - 무한 깊이 문제
        - DFS는 무한히 깊은 경로를 탐색할 때 무한 루프에 빠질 수 있다.
        - 이를 방지하기 위해 최대 깊이 제한을 두거나 방문한 노드를 표시하는 등의 추가 로직이 필요할 수 있다.
        - BFS는 레벨 단위로 탐색하므로 이런 문제가 발생할 가능성이 낮다.
