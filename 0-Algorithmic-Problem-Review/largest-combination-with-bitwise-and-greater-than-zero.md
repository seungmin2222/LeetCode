## [**Largest Combination With Bitwise AND Greater Than Zero**](https://leetcode.com/problems/largest-combination-with-bitwise-and-greater-than-zero/)

이 문제는 주어진 배열에서 가능한 모든 조합의 비트 AND 연산 결과가 0보다 큰 경우, 가장 큰 조합의 크기를 반환하는 문제이다.

## 나의 코드

```jsx
var largestCombination = function(candidates) {
    let max = 0;

    for (let i = 0; i < 32; i++) {
        let count = 0;
        for (let num of candidates) {
            if ((num >> i) & 1) {
                count++;
            }
        }
        max = Math.max(max, count);
    }

    return max;
};
```

## 나의 수도 코드

1. 각 숫자의 비트를 0부터 31까지 검사하면서, 해당 비트가 1인 숫자의 개수를 센다.
2. 각 비트 위치에서 가장 많은 숫자를 포함한 비트 AND 조합의 크기를 갱신한다.
3. 최종적으로 가장 큰 크기를 반환한다.

## 시간 복잡도

**O(n)**배열의 모든 숫자에 대해 최대 32비트(정수의 비트 길이)를 순회하기 때문에, 시간 복잡도는 숫자 배열의 크기 n에 비례한다.

최종 시간 복잡도는 **O(n × 32)이다.**

## 공간 복잡도

추가적인 메모리를 거의 사용하지 않으므로 상수 공간 복잡도를 가진다.

최종 공간 복잡도는 O(1)이다.

## 알아둬야 할 것!

1. **비트 AND 연산의 기본 개념**
    - 두 숫자의 동일한 비트가 모두 1일 때 결과 비트가 1이 되는 연산이다.
2. **비트 이동 연산 (Bit Shifting)**
    - 특정 비트를 검사하기 위해 숫자를 오른쪽으로 이동시키는 방식이다.
- **비트마스크 (Bit Mask)**
    - 비트 연산에서 특정 비트를 선택하거나 제거하는 데 사용된다.
    - 이 문제에서는 비트가 1인 숫자를 찾기 위해 활용된다.

## 회고

이번 문제를 통해 비트 연산의 효율성과 활용 방법을 깊이 이해할 수 있었다.

특히, 비트 AND 연산과 비트 이동(Shift)을 활용하여 각 비트 위치에서 독립적으로 최대 조합을 계산하는 방법이 흥미로웠다.

32비트 정수 제한을 기반으로 설계된 로직은 현대 컴퓨터 아키텍처의 기본 개념과 연결된다는 점에서도 흥미로웠다.

이 문제를 통해 앞으로 비트 연산을 더 깊이 연구하여 응용 범위를 확장하고자 한다.
