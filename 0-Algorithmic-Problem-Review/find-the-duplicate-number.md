## [**Find the Duplicate Number**](https://leetcode.com/problems/find-the-duplicate-number/)

이 문제는 정수 배열 nums가 주어졌을 때, nums에 반복되는 숫자가 하나만 있을 때 이 반복되는 숫자를 반환하는 문제이다.

## 주요 포인트

1. **객체를 이용한 중복 체크**
    - `nums[i]`가 처음 나타나면 객체에 그 숫자를 키로 추가하고, 이미 등장한 숫자라면 중복된 숫자로 간주하여 즉시 반환한다.
2. **순차적인 배열 탐색**
    - `for` 루프를 통해 배열을 순차적으로 탐색하면서 각 숫자가 이전에 등장했는지 검사한다.
    - 시간 복잡도는 O(n)으로, 배열의 모든 요소를 한 번씩 순회하며 중복을 찾는다.
3. **빠른 중복 감지**
    - 중복을 발견하는 즉시 (`else` 절에서) 해당 숫자를 반환하므로, 첫 번째로 발견되는 중복을 빠르게 반환한다.
    - 최악의 경우에도 모든 숫자를 한 번씩 탐색하며 중복을 찾게 된다.
4. **추가 메모리 사용**
    - 이 코드의 가장 중요한 특징은 **추가 메모리**(객체 `obj`)를 사용하여 중복을 추적한다는 점이다.
    - 배열에 있는 숫자들을 키로 저장하기 때문에 최악의 경우, 배열의 길이 `n`만큼의 공간이 필요하다.

## 나의 코드

```jsx
var findDuplicate = function(nums) {
  const obj = {};
  for (let i = 0; i < nums.length; i++) {
    if (obj[nums[i]] === undefined) {
      obj[nums[i]] = 1;
    } else {
      return nums[i];
    }
  }
};
```

## 나의 수도 코드

1. `obj`라는 빈 객체를 생성하여 숫자의 출현 여부를 기록한다.
2. 배열 `nums`를 순차적으로 탐색합니다. 각 숫자를 `현재 숫자`로 설정한다.
3. `obj`에 `현재 숫자`가 키로 존재하는지 확인한다.
4. **존재하지 않는 경우**: 해당 숫자를 `obj`에 키로 추가하고 값을 1로 설정하여 추적한다.
5. **존재하는 경우**: 해당 숫자가 이미 `obj`에 키로 존재하면, 이는 중복된 숫자를 찾았다는 의미이므로 즉시 반환한다.
6. 중복된 숫자를 찾으면 반복문을 종료하고 그 숫자를 반환한다.

## 다른 사람의 풀이

```jsx
var findDuplicate = function(nums) {
    let tortoise = nums[0];
    let hare = nums[0];

    do {
        tortoise = nums[tortoise];
        hare = nums[nums[hare]];
    } while (tortoise !== hare);

    tortoise = nums[0];
    while (tortoise !== hare) {
        tortoise = nums[tortoise];
        hare = nums[hare];
    }

    return hare;
};
```

## 다른 사람의 수도 코드

1. **사이클 탐지 단계**
    - 거북이(`tortoise`)와 토끼(`hare`)를 모두 배열의 첫 번째 요소로 초기화한다.
    - `do-while` 루프에서
        - 거북이는 한 칸씩 이동: `거북이 = nums[거북이]`.
        - 토끼는 두 칸씩 이동: `토끼 = nums[nums[토끼]]`.
    - 이 단계에서 거북이와 토끼가 만날 때까지 반복하여 사이클을 탐지한다.
    - 이 루프가 끝나면, 배열 내에서 숫자의 중복으로 인해 형성된 사이클이 감지된다.
2. **사이클의 시작점 찾기**
    - 사이클이 감지되면, 거북이를 배열의 시작점으로 다시 이동시킨다. `거북이 = nums[0]`.
    - 거북이와 토끼를 한 칸씩 이동하면서 다시 만날 때까지 반복한다.
        - 거북이와 토끼는 둘 다 한 칸씩 이동한다: `거북이 = nums[거북이]`, `토끼 = nums[토끼]`.
    - 거북이와 토끼가 다시 만나는 지점이 중복된 숫자이다.
3. **반환**
    - 두 포인터가 만난 위치를 반환합니다. 이 위치가 배열에 있는 중복된 숫자이다.

### 핵심 개념

- **사이클 탐지**: 토끼와 거북이 알고리즘을 사용하여 배열 내에서 사이클을 탐지한다.
이는 배열을 링크드 리스트로 간주하고, 중복된 숫자가 사이클을 형성한다는 점을 이용한 것이다.
- **사이클의 시작점 찾기**: 탐지된 사이클의 시작점을 찾아 중복된 숫자를 반환한다.
- **공간 효율성**: 이 알고리즘은 상수 공간(O(1))만 사용하며, 문제의 제약 조건을 만족한다.

## 알아둬야 할 것!

**Floyd의 토끼와 거북이 알고리즘**은 주로 **링크드 리스트나 배열에서 사이클을 탐지**하는 데 사용되는 알고리즘이다.

이 알고리즘은 "토끼와 거북이 경주"에 비유할 수 있으며, 두 개의 포인터(토끼와 거북이)를 사용하여 순환 구조(사이클)를 찾아내는 효율적인 방법이다.

### ✨ 개념 설명

- **포인터 2개 사용**
    - **거북이(Tortoise)**: 한 번에 **한 칸**씩 이동하는 느린 포인터.
    - **토끼(Hare)**: 한 번에 **두 칸**씩 이동하는 빠른 포인터.
- **사이클 탐지**
    - 만약 주어진 구조(예: 배열, 링크드 리스트)에 사이클이 있다면, 토끼와 거북이는 결국 사이클 안에서 만나게 된다.
    - 이는 빠른 포인터(토끼)가 느린 포인터(거북이)를 사이클을 따라 여러 번 돌아다니는 동안 결국 따라잡기 때문이다.

### 🌟 알고리즘 단계별 설명

1. **사이클 탐지 단계**
    - 포인터 두 개를 배열이나 링크드 리스트의 시작점에 놓는다.
    - 거북이는 한 번에 한 칸씩 이동하고, 토끼는 두 칸씩 이동한다.
    - 두 포인터가 **언젠가 서로 만나게 된다면**, 구조에 사이클이 있다는 것을 알 수 있다.
    - 이때 두 포인터가 만나게 되는 지점은 **사이클 안**의 임의의 한 위치일 뿐이다.
2. **사이클의 시작점 찾기**
    - 사이클이 발견되면, 거북이 포인터를 시작점으로 다시 초기화한다.
    - 이제 두 포인터 모두 **한 칸씩** 이동한다.
    - 두 포인터가 다시 만나는 지점이 **사이클의 시작점이**다. 이 지점이 문제의 해답, 즉 **중복된 숫자이**다.
3. **반환**
    - 두 포인터가 만나게 되는 지점을 반환한다. 이는 배열에서 중복된 숫자를 가리킨다.

## 회고

이번 문제를 처음 풀었을 때, 나는 중복된 숫자를 찾기 위해 **객체를 사용하여 숫자의 출현 여부를 추적**하는 방식을 선택했다. 이 방법은 구현이 간단하고 중복을 빠르게 찾을 수 있다는 장점이 있었지만, 배열의 크기에 비례하여 객체를 생성하기 때문에 공간 복잡도가 O(n)이 되어 문제의 조건인 상수 공간(O(1))을 만족하지 못했다.

문제를 해결하는 더 나은 방법이 있을 것이라고 생각했고, 다른 사람의 코드를 살펴보던 중 토끼와 거북이 알고리즘(Floyd의 Cycle Detection Algorithm)을 알게 되었다. 이 알고리즘은 두 개의 포인터를 사용하여 배열 내에서 사이클을 탐지하는 독특한 방식이다. 사이클이 있다는 것을 이용하여 **중복된 숫자를 찾는다는 점**이 신선하게 다가왔다.

토끼와 거북이 알고리즘을 이해하고 나서, 이 문제를 어떻게 **상수 공간**을 사용하여 해결할 수 있는지 명확하게 알 수 있었다. 특히, 이 알고리즘은 배열의 숫자들을 링크드 리스트의 노드처럼 활용해 사이클을 찾아내는 원리를 적용하였고, 이를 통해 중복된 숫자를 정확히 찾아내는 방법을 배울 수 있었다.

이번 문제를 통해 간단한 아이디어로는 제한 조건을 모두 충족시키지 못할 수 있다는 것을 깨달았다. 또한, 효율적인 알고리즘에 대한 지식이 중요하며, 새로운 알고리즘을 배움으로써 문제를 더 나은 방식으로 해결할 수 있다는 것을 배우게 되었다.

앞으로 비슷한 문제에 직면할 때, 더 다양한 접근 방법을 시도하고 최적화된 알고리즘을 찾아 적용해 볼 수 있는 자신감이 생겼다.
