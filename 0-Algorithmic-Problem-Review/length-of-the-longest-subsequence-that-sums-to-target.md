## [**Length of the Longest Subsequence That Sums to Target**](https://leetcode.com/problems/length-of-the-longest-subsequence-that-sums-to-target/)

주어진 정수 배열 `nums`에서 `target`과 합이 같은 가장 긴 부분 수열의 길이를 구하는 문제다.

만약 그런 부분 수열이 없다면 `-1`을 반환한다.

## 주요 포인트

1. **합이 특정 값과 일치하는 부분 수열 찾기**
    - 문제의 목표는 주어진 `target` 값을 만들 수 있는 부분 수열 중 가장 긴 길이를 찾는 것이다.
    - 모든 가능한 부분 수열을 고려하여 각 경우의 합이 `target`과 일치하는지 확인해야 한다.
2. **백트래킹(Backtracking)의 필요성**
    - 부분 수열의 모든 조합을 살펴보기 위해 백트래킹을 사용해야 한다.
    - 백트래킹을 통해 현재 원소를 포함하거나 포함하지 않는 두 가지 경우를 모두 탐색하면서 모든 가능한 부분 수열을 조사할 수 있다.

## 나의 코드

```jsx
function longestSubsequence(nums, target) {
    let maxLen = -1;

    function backtrack(index, currentSum, length) 
        if (currentSum === target) {
            maxLen = Math.max(maxLen, length);
        }

        if (index === nums.length) return;

        backtrack(index + 1, currentSum + nums[index], length + 1);
        backtrack(index + 1, currentSum, length);
    }

    backtrack(0, 0, 0);

    return maxLen;
}

```

## 나의 수도 코드

1. **백트래킹 함수 `backtrack(index, currentSum, length)` 정의**
    - `index` : 현재 탐색 위치.
    - `currentSum`  :  현재까지의 합.
    - `length` : 현재 부분 수열의 길이.
2. `currentSum`이 `target`과 같으면
    - `maxLen`을 현재 `length`와 비교하여 더 큰 값으로 업데이트.
    - `target`과 일치하는 부분 수열의 최대 길이를 갱신.
3. `index`가 배열의 길이와 같으면 탐색을 종료 → 재귀 함수에서 돌아감.
4. **현재 원소를 포함하는 경우** 현재 `index`의 원소를 포함하여 다음 재귀 호출.
    - `currentSum`에 현재 원소 값을 더하고, `length`를 1 증가시켜 호출.
5. **현재 원소를 포함하지 않는 경우** 현재 `index`의 원소를 포함하지 않고 다음 재귀 호출을 수행.
    - `currentSum`과 `length`는 그대로 두고 `index`만 증가시켜 호출.
6. **백트래킹 탐색 시작**
    - `backtrack(0, 0, 0)`으로 인덱스 0, 합 0, 길이 0부터 백트래킹 탐색을 시작.
7. 모든 탐색이 끝난 후, `maxLen`이 여전히 -1이면  -1을 반환합니다.
    - 그렇지 않으면 `maxLen`을 반환.

## 시간 복잡도

1. **백트래킹을 통한 부분 수열 탐색**
    
    `nums` 배열의 각 원소는 포함하거나 포함하지 않는 두 가지 선택이 있으므로, 모든 가능한 부분 수열의 개수는 `2^n`이다.
    
    고로 최악의 경우 백트래킹을 사용해 `2^n` 개의 부분 수열을 탐색한다.
    
2. **각 부분 수열에 대해 작업 수행**
    
    각 부분 수열을 탐색할 때, 현재 부분 수열의 합과 길이를 확인하는 작업은 상수 시간에 가능하다.
    

**따라서 시간 복잡도**는 `O(2^n)`이다.

## 공간 복잡도

1. **재귀 호출 스택**
    
    백트래킹을 사용한 재귀 호출로 인해 최대 `n` 레벨의 재귀 호출 스택이 필요하다.
    
    각 호출은 새로운 `index`, `currentSum`, `length` 상태를 유지해야 하므로 재귀 호출 스택에 `O(n)`의 공간이 필요하다.
    
2. **추가 변수**
    
    `maxLen` 같은 상수 크기의 변수를 제외하면, 백트래킹 함수 내부에서 별도의 메모리 공간이 추가로 필요하지 않는다.
    

따라서 **공간 복잡도**는 `O(n)`이다.

## 알아둬야 할 것!

1. **부분 수열과 완전 탐색**
    
    배열의 모든 부분 수열을 탐색하는 방법을 이해한다.
    
2. **백트래킹(Backtracking)**
    
    백트래킹을 통해 모든 가능한 선택지를 탐색하면서 조건에 맞는 결과를 찾는 기법을 학습할 수 있다.
    
    조건을 충족하는 경우만 결과를 업데이트하는 방식이 포인트이다.
    
3. **재귀 호출과 호출 스택**
    
    재귀 함수를 통해 상태를 유지하며 탐색을 진행하는 방식과, 재귀 호출 스택이 차지하는 메모리 구조를 이해하게 된다.
    

## 회고

이번 문제를 풀면서 부분 수열을 백트래킹으로 탐색하는 방법을 한번 더 복습해 보았다.

모든 가능한 부분 수열을 탐색하면서 합을 확인하고, 조건에 맞는 가장 긴 부분 수열을 찾는 과정의 문제였다.

특히, 재귀 호출과 호출 스택의 구조를 이해하면서 메모리와 시간 복잡도 관리의 중요성을 느꼈다.
