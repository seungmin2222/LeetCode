## [Largest Number](https://leetcode.com/problems/largest-number/)

이 문제는 주어진 숫자 배열을 사용하여 가장 큰 수를 형성하는 것이다.

## 주요 포인트

1. 숫자를 연결하는 순서를 적절히 정렬하여 가장 큰 수를 만들어야 한다. 
2. 두 숫자 `a`와 `b`를 비교할 때, 문자열로 변환한 후 `a + b`와 `b + a`를 비교하는 방식으로 정렬한다. 
3. `a + b`가 `b + a`보다 크다면 `a`를 앞에 두는 방식으로 정렬하면 된다.

## 나의 코드

```jsx
var largestNumber = function(nums) {
  nums.sort((a, b) => {
    let strA = a.toString();
    let strB = b.toString();
    return (strB + strA) - (strA + strB);
  });
  
  if (nums[0] === 0) return "0";
  
  return nums.join('');
};

```

## 나의 수도 코드

1. `nums` 배열을 정렬. 
    - 정렬 기준은 `(b + a) - (a + b)`로, `a`와 `b`의 순서를 변경해 연결했을 때 더 큰 값을 만드는 방향으로 정렬.
2. 숫자들이 연결된 배열을 문자열로 변환하여 반환.
3. 모든 숫자가 `0`일 경우 "0"을 반환하도록 처리.

## 시간 복잡도

- 핵심 로직은 `Array.sort()` 메서드를 사용하는 것이다.
- `Array.sort()` 메서드는 대부분 퀵 정렬 알고리즘을 사용하므로, 평균 및 최악의 시간 복잡도는 O(n log n)이다.
- 정렬 후에는 O(n) 시간이 소요되어 문자열로 변환하고 이어붙이는 작업을 수행한다.
- 따라서 이 코드의 전체 시간 복잡도는 O(n log n)이다.

## 공간 복잡도

- 이 코드는 입력 배열 `nums`를 정렬하는 것 이외에 별도의 데이터 구조를 사용하지 않지만, 정렬 과정에서 내부적으로 추가 메모리를 사용할 수 있다.
- 따라서 입력 크기에 따라 변동하는 메모리를 고려해야 하므로, 공간 복잡도는 O(n)이다.

## 알아둬야 할 것!

### 정렬 방식

```jsx
nums.sort((a, b) => {
  let strA = a.toString();
  let strB = b.toString();
  return (strB + strA) - (strA + strB);
});
```

이 방식은 각 숫자 `a`와 `b`를 **문자열로 변환하여 두 숫자의 순서를 바꾸며** 비교하는 방식을 이해 해야한다.

각 숫자를 조합했을 때 **더 큰 수가 되는 순서**를 찾는다.

이 과정을 통해 최종적으로 가장 큰 수를 만들 수 있게 된다.

### 예시

예를 들어, 숫자 배열 `[3, 30, 34, 5, 9]`가 있을 때, 우리가 원하는 것은 이 숫자들을 조합해 가장 큰 수를 만드는 것이다.

1. `a`와 `b`가 두 개의 숫자라고 가정. 
    - `a`와 `b`를 문자열로 변환한 후, **`a + b`와 `b + a`를 비교.**
        - `a = 3`이고 `b = 30`이라면
            - `a + b`는 `"3" + "30" = "330"`
            - `b + a`는 `"30" + "3" = "303"`
    - 두 문자열을 비교했을 때 `"330"`이 `"303"`보다 크므로, `3`을 `30`보다 앞에 두는 것이 전체적으로 더 큰 수를 만드는 방향임을 알 수 있다.
2. 이러한 방식으로 정렬을 수행하면, 최종 배열은 가장 큰 수를 형성하는 순서로 정렬된다는 걸 알 수 있다.

## 회고

이번 문제는 숫자 배열을 조합해 가장 큰 수를 만드는 것이 목표였다.

숫자를 문자열로 변환한 후 `a + b`와 `b + a`를 비교해 큰 수가 되는 순서로 정렬하는 방식을 사용했다.

단순한 숫자 비교 대신 문자열 조합을 이용한 비교가 필요하다는 점이 포인트였다. `sort` 정렬을 통해 문제를 해결할 수 있었다.
