# [K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/)

주어진 x, y 좌표가 담긴 배열들의 집합에서 각 점이 원점(0, 0)으로부터 얼마나 가까운지를 계산하고, 원점에서 가장 가까운 k개의 점을 반환하는 문제다.

## 주요 포인트

1. **거리 제곱 계산**
    - 각 점에서 원점(0, 0)까지의 거리를 구하는 대신, 거리 제곱을 계산하여 비교에 사용한다. 이는 계산 속도를 높이면서도 정확한 비교를 가능하게 한다.
2. **정렬**
    - 계산된 거리 제곱 값을 기준으로 점들을 정렬한다. 이 과정에서 거리가 가까운 점들이 앞에 오도록 한다.
3. **상위 `k`개의 점 선택**
    - 정렬된 점들 중에서 가장 가까운 `k`개의 점을 선택하여 반환한다.

## 나의 코드

```js
var kClosest = function(points, k) {
  const sqrt = [];
  const answer = [];
  
  for (let i = 0; i < points.length; i++) {
    const num = points[i][0] ** 2 + points[i][1] ** 2
    sqrt.push([points[i], [num]]);
  }
  
  sqrt.sort((a, b) => {
    return b[1][0] - a[1][0];
  });
  
  for (let i = 0; i < k; i++) {
    const minArr = sqrt.pop();
    answer.push(minArr[0]);
  }
  
  return answer;
};
```

## 나의 수도 코드

1. **입력 변수 초기화**
    1. `sqrt` 배열과 `answer` 배열을 빈 배열로 초기화한다.
2. **각 점에 대한 거리 제곱 계산**
    1. 현재 점의 x좌표와 y좌표를 제곱하여 거리의 제곱(`num`)을 계산
    2. 계산된 거리 제곱값과 해당 점을 `sqrt` 배열에 추가
3. **거리 제곱값에 따라 내림차순으로 정렬**
    1. `sqrt` 배열을 거리 제곱값을 기준으로 내림차순으로 정렬
4. **가장 가까운 k개의 점 선택**
    1. `sqrt` 배열의 마지막 요소(거리가 가장 작은 점)를 추출하여 `answer` 배열에 추가
    2. 이를 `k`번 반복
5. **결과 반환**
    1. `answer` 배열을 반환하여 원점에서 가장 가까운 `k`개의 점을 반환

## 다른 사람의 풀이

```js
var kClosest = function(points, k) {
  points.sort((a, b) => {
    return (a[0] ** 2 + a[1] ** 2) - (b[0] ** 2 + b[1] ** 2);
  });
  
  return points.slice(0, k);
}; 
```

1.  거리 제곱을 계산하여 points와 함께 새로운 배열로 저장
2. 정렬된 points 배열에서 가장 가까운 k개의 점 반환

## 회고

### **1. 거리 계산과 정렬의 효율성**

- **주어진 코드**: 거리 제곱을 계산한 후, 이를 배열(`sqrt`)에 저장하고, 다시 이 배열을 내림차순으로 정렬한 다음, `pop()`을 사용해 가장 작은 거리의 점을 추출하는 방식이다. 이 과정에서 배열을 역순으로 정렬한 후 `pop()`을 사용하는 것은 비효율적이다.
- **최적화된 코드**: 거리 제곱을 계산하면서 바로 `points` 배열을 오름차순으로 정렬한다. 이로써 필요 없는 역순 정렬과 `pop()` 연산을 제거하여 코드의 효율성을 높혔다.

### 2. **코드 간결성**

- **주어진 코드**: 거리 제곱 계산, 정렬, `pop()`을 통한 점 추출이라는 여러 단계를 거친다. 각각의 과정이 분리되어 있어 코드가 길어지고 복잡해진다.
- **최적화된 코드**: `sort()`와 `slice()`를 사용해 필요한 점들을 한 번에 처리한다. 이로 인해 코드가 훨씬 간결해지고, 전체 로직을 이해하기가 더 쉬워졌다.

이번 코드를 작성하면서 **`sort()`** 메서드에 대한 이해도가 부족했음을 반성하게 되었다. 초기 코드에서는 거리 제곱 값을 구한 후 배열을 내림차순으로 정렬하고, `pop()`을 사용해 가장 가까운 점들을 선택하는 비효율적인 방식을 사용했다. 이는 정렬의 방향성을 제대로 고려하지 않은 채, 문제를 복잡하게 풀려 했던 결과였다.

특히, **`sort()`** 메서드가 오름차순으로 정렬된 배열에서 필요한 `k`개의 요소를 쉽게 가져올 수 있다는 점을 간과했다. 이로 인해 불필요한 메모리 사용과 복잡한 코드를 작성하게 되었고, 성능 또한 비효율적이게 되었다.

이 경험을 통해 `sort()` 메서드의 사용 방법과 그 중요성을 다시 한 번 깨닫게 되었으며, 앞으로는 정렬의 방향성 및 메서드의 특성을 명확히 이해하고 활용할 수 있도록 더 깊이 고민하고 학습해야겠다는 다짐을 하게 되었다.
