# [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)
이 문제는 주어진 정수 배열 `nums`에서, `answer[i]`가 `nums[i]`를 제외한 나머지 모든 요소의 곱이 되도록 하는 배열을 반환하는 문제이다.

단 O(n) 시간 복잡도로 작동해야 하며, 나눗셈을 사용할 수 없다.

## 주요 포인트

1. 각 요소를 제외한 나머지 요소들의 곱을 계산하는 배열을 생성해야 한다.
2. 시간 복잡도는 O(n)으로 제한되며, 추가적으로 나눗셈 연산은 허용되지 않는다.
3. 왼쪽에서 오른쪽으로 곱을 계산하고, 다시 오른쪽에서 왼쪽으로 곱을 계산하는 두 번의 순회를 사용한다.
4. 최종 배열은 두 순회에서 계산된 곱의 값을 결합하여 만들어진다.

## 나의 코드

```jsx
var productExceptSelf = function(nums) {
  const n = nums.length;
  const output = new Array(n).fill(1);

  let leftProduct = 1;
  for (let i = 0; i < n; i++) {
    output[i] = leftProduct;
    leftProduct *= nums[i];
  }

  let rightProduct = 1;
  for (let i = n - 1; i >= 0; i--) {
    output[i] *= rightProduct;
    rightProduct *= nums[i];
  }

  return output;
};
```

## 나의 수도코드

1. **입력 초기화**
    - `nums` 배열의 길이를 `n`으로 저장
    - 길이가 `n`인 `output` 배열을 모두 `1`로 초기화
2. **왼쪽 곱 계산**
    - `leftProduct`를 `1`로 초기화
    - 배열의 왼쪽에서 오른쪽으로 순회
        - 현재 인덱스 `i`에서의 `output[i]`에 `leftProduct` 값을 저장
        - `leftProduct`에 `nums[i]`를 곱하여 업데이트
3. **오른쪽 곱 계산**
    - `rightProduct`를 `1`로 초기화
    - 배열의 오른쪽에서 왼쪽으로 순회
        - 현재 인덱스 `i`에서의 `output[i]`에 `rightProduct` 값을 곱한다.
        - `rightProduct`에 `nums[i]`를 곱하여 업데이트
4. **결과 반환**
    - 최종적으로 계산된 `output` 배열을 반환

## 공간 복잡도란?

공간 복잡도는 프로그램이나 알고리즘이 실행될 때 사용하는 메모리의 양을 나타내는 지표이다. 이 메모리 사용량은 주로 알고리즘이 입력 데이터를 처리하는 과정에서 필요로 하는 저장 공간의 크기에 의해 결정된다. 공간 복잡도는 일반적으로 입력 크기에 대한 함수로 표현되며, 알고리즘이 효율적으로 메모리를 사용하는지 평가하는 중요한 기준 중 하나이다.

### 공간 복잡도를 계산할 때는 두 가지 주요 요소를 고려

1. **고정된 메모리 사용량**
    
    고정된 메모리 사용량은 입력 크기와 무관하게 일정하게 소요되는 메모리 양을 의미한다. 예를 들어, 알고리즘이 사용하는 변수, 상수, 또는 포인터 등의 메모리 공간은 입력 크기에 관계없이 일정하다. 이 경우, 공간 복잡도는 O(1)로 표현되며, 이는 "상수 공간 복잡도"라고 불린다.
    
2. 가변적인 메모리 사용량
    
    가변적인 메모리 사용량은 입력 크기에 따라 달라지는 메모리 사용량을 의미한다. 예를 들어, 알고리즘이 입력 데이터 크기에 비례하여 배열, 리스트 등의 자료 구조를 추가적으로 생성할 때, 이 자료 구조들이 차지하는 메모리 공간이 가변적이다. 이러한 경우, 공간 복잡도는 **O(n)**으로 표현되며, 여기서 `n`은 입력 데이터의 크기를 나타낸다.
    

공간 복잡도를 최적화하는 것은 알고리즘 설계에서 중요한 과제 중 하나이다. 시간 복잡도와 함께 고려하여 알고리즘이 효율적으로 동작하면서도 메모리를 낭비하지 않도록 설계해야 한다. 예를 들어, 불필요하게 큰 자료 구조를 사용하지 않거나, 입력 데이터를 직접 변형함으로써 추가적인 메모리 사용을 줄일 수 있다.

결론적으로, 공간 복잡도는 알고리즘의 메모리 효율성을 평가하는 데 필수적인 개념으로, **O(1)**, **O(n)** 등의 표기법을 통해 알고리즘이 사용하는 메모리의 양을 간결하게 표현한다. 이를 통해 알고리즘의 성능을 최적화하고, 시스템의 메모리 자원을 효율적으로 활용할 수 있다.

### O(1)의 의미

- O(1)은 **상수 시간/공간 복잡도**를 의미한다.
- 여기서 상수(constant)라는 것은 입력 크기와 상관없이 일정한 시간을 소요하거나 일정한 메모리를 사용하는 것을 뜻한다.
- 다시 말해, 입력 데이터의 크기와 무관하게 알고리즘이 필요로 하는 작업의 양이나 메모리 사용량이 변하지 않는다는 의미이다.

### ex)

- 어떤 함수가 주어진 입력에서 항상 특정 위치의 값을 조회하는 작업을 한다면, 이 작업은 입력 크기와 상관없이 동일한 시간이 걸린다. 이 경우 시간 복잡도는 O(1)이다.
- 만약 알고리즘이 입력 크기에 상관없이 특정 개수의 변수만 사용한다면, 이때 공간 복잡도는 O(1)이다.
    - 예를 들어, 두 개의 변수만을 사용해 입력 데이터를 처리하는 경우가 이에 해당한다.

### O(n)의 의미

- *O(n)**은 **선형 시간/공간 복잡도**를 의미한다.
- 여기서 선형(linear)이라는 것은 입력 크기에 비례하여 작업량이나 메모리 사용량이 증가하는 것을 뜻한다.
- 입력 데이터의 크기가 커지면 커질수록 필요한 시간이나 메모리도 그에 비례하여 증가한다는 의미이다.

### ex)

- 어떤 알고리즘이 리스트나 배열의 모든 요소를 한 번씩 검사하는 작업을 수행한다면, 이 작업은 리스트의 크기에 비례해서 시간이 늘어난다. 리스트가 10개일 때와 100개일 때 걸리는 시간이 다르다. 이 경우 시간 복잡도는 O(n)이다.
- 만약 알고리즘이 입력 데이터 크기에 비례하여 새로운 배열을 생성한다면, 이 배열이 차지하는 메모리 역시 입력 데이터 크기만큼 필요하므로 공간 복잡도는 O(n)이다.

### 요약

- **O(1)**: 입력 크기와 무관하게 일정한 시간이나 메모리를 사용하는 경우.
- **O(n)**: 입력 크기에 비례하여 시간이나 메모리 사용량이 증가하는 경우.

이 두 가지 개념을 통해 알고리즘의 효율성을 평가할 수 있다.

O(1)이 O(n)보다 일반적으로 더 효율적이며, 입력 크기가 커질수록 그 차이는 더욱 두드러지게 나타난다.

## 회고

이번에 알고리즘과 공간 복잡도에 대해 공부하면서, 효율적인 코드를 작성하는 데 필요한 기본 개념들을 다시 한 번 깊이 이해할 수 있었다. 단순히 문제를 해결하는 것에 그치지 않고, 얼마나 빠르고 적은 자원으로 문제를 풀 수 있는지를 고려해야 한다는 점이 인상 깊었다.

### 알고리즘 이해의 깊이

알고리즘을 공부하면서, 다양한 방법으로 문제를 해결할 수 있지만, 그 중에서 최적화된 알고리즘을 선택하는 것이 중요하다는 걸 깨달았다. 시간 복잡도와 함께 공간 복잡도를 고려하는 능력이 프로그램의 성능을 크게 좌우한다는 점을 다시 한 번 실감했다.

### 공간 복잡도의 중요성

공간 복잡도를 학습하면서, 메모리가 제한된 환경에서 효율적으로 프로그램을 설계하는 방법을 고민하게 됐다. 특히 O(1) 공간 복잡도를 유지하는 것이 얼마나 중요한지, 불필요한 메모리 사용을 줄이는 것이 실전 프로그래밍에서 필수적이라는 것을 깨달았다.

### O(1)과 O(n)의 차이점 이해

O(1)과 O(n)의 개념을 통해 입력 크기에 따라 알고리즘의 효율성이 어떻게 달라질 수 있는지 명확히 이해했다. O(1) 공간 복잡도를 유지하는 것이 대규모 데이터를 처리할 때 얼마나 중요한지, 그리고 O(n) 이상의 복잡도를 가지는 알고리즘이 성능 저하를 일으킬 수 있다는 점을 학습했다.

### 향후 학습 방향

이번 학습을 통해 얻은 교훈은, 단순히 코드를 작성하는 것에서 멈추지 않고 최적화된 알고리즘을 찾기 위해 계속해서 고민해야 한다는 것이다. 앞으로 다양한 알고리즘 패턴을 학습하고, 그에 따른 시간 및 공간 복잡도를 분석하는 연습을 할 예정이다. 이를 통해 실제 프로젝트에서 더 나은 코드를 작성할 수 있도록 노력할 것이다.

결국, 이번 알고리즘과 공간 복잡도 공부는 나의 프로그래밍 능력을 한 단계 끌어올리는 계기가 되었고, 앞으로 이를 바탕으로 더 효율적이고 최적화된 코드를 작성하는 데 힘쓸 것이다.
