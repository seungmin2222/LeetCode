## [Max Chunks To Make Sorted](https://leetcode.com/classic/problems/max-chunks-to-make-sorted/description/)

배열 `arr`를 몇 개의 구간(chunks)으로 나누어 각각 정렬한 뒤 합쳤을 때, 전체 배열이 정렬된 상태가 되도록 만들 수 있는 최대 구간의 수를 구하는 문제이다.

## 주요 포인트

1. 배열을 순회하며 현재까지의 최댓값(maxSeen)을 추적한다.
2. 현재 인덱스와 `maxSeen`이 같으면, 해당 구간까지를 하나의 독립적인 **chunk**로 나눌 수 있다.
3. 각 구간은 독립적으로 정렬 가능하며, 최종적으로 합쳐도 배열이 정렬된 상태를 유지한다.
4. 모든 인덱스를 확인한 뒤, 가능한 최대 **chunk**의 개수를 반환한다.

## 나의 코드

```jsx
var maxChunksToSorted = function(arr) {
    let maxSeen = 0; 
    let chunks = 0;

    for (let i = 0; i < arr.length; i++) {
        maxSeen = Math.max(maxSeen, arr[i]);

        if (maxSeen === i) {
            chunks++;
        }
    }

    return chunks;
};
```

## 나의 수도 코드

1. `maxSeen`과 `chunks`를 0으로 초기화.
2. 배열을 처음부터 끝까지 순회
    - `maxSeen`을 현재 값과 비교해 업데이트
        - `maxSeen = max(maxSeen, arr[i])`.
    - `maxSeen === i`라면, `chunks`를 1 증가.
3. 순회가 끝난 뒤, `chunks`를 반환.

## 시간 복잡도

1. 배열을 한 번 순회하면서 `maxSeen`을 업데이트하고 조건을 확인.
    - 순회에 걸리는 시간은 배열의 길이 `n`에 비례.
    - 각 업데이트 연산(`Math.max`)와 비교 연산은 O(1)이다.

최종 시간 복잡도는 O(n)이다.

## 공간 복잡도

1. 사용한 추가 변수
    - `maxSeen`과 `chunks`는 각각 하나의 정수를 저장하므로 O(1)입니다.
2. 입력 배열 `arr`를 그대로 사용하고, 별도의 데이터 구조를 사용하지 않는다.

최종 공간 복잡도는 O(1)입니다.

## 알아둬야 할 것!

1. 배열에서 현재 인덱스까지의 값 중 최댓값이 현재 인덱스와 같다면, 해당 구간이 정렬 가능한 독립적인 블록이 된다.
2. 배열의 순열 특성(0부터 n-1까지의 값 포함)을 활용해, 각 인덱스가 올바른 자리에 도달했는지를 판별하는 방법.
3. 한 번의 순회와 최소한의 변수로 문제를 해결하며, 추가 메모리 없이도 최대 구간 수를 구할 수 있다.

## 회고

이번 문제는 배열을 순회하며 최댓값을 추적하는 간단한 아이디어로 해결할 수 있는 문제였다.

특히, 한 번의 순회로 시간 복잡도를 O(n)으로 최적화하고, 추가 메모리 없이도 해결할 수 있었던 점이 잘 했던 문제 해결 방법인것 같다.

문제를 풀면서 정렬 가능성에 대한 새로운 관점을 배울 수 있었고, 비슷한 문제를 만났을 때도 조건 기반으로 구간을 나누는 방법을 떠올릴 수 있을 것 같다.
