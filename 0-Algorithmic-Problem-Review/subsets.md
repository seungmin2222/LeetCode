## [Subsets](https://leetcode.com/problems/subsets)

이 문제는 주어진 배열 `nums`의 모든 가능한 부분 집합(즉, power set)을 구하는 문제이다.

배열 내의 원소는 중복되지 않으며, 결과에 중복된 부분 집합이 없어야 한다.

## 주요 포인트

- **부분 집합(Subsets)**
    - 주어진 집합에서 가능한 모든 원소의 조합을 구하는 것. 공집합도 반드시 포함되며, 순서는 상관없음
- **반복문과 배열 조작(Iteration and Array Manipulation)**
    - 반복문을 사용하여 배열을 순차적으로 처리하고, 기존 배열을 기반으로 새로운 배열을 만드는 방법
- **반복을 통한 동적 집합 확장**
    - 부분 집합을 구할 때, 각 원소를 기존 부분 집합에 추가하여 새로운 부분 집합을 만들어내는 방법

## 나의 코드

```tsx
var subsets = function(nums) {
  const result = [[]];
  
  while (nums.length) {
    const num = nums.shift();
    const leg = result.length;
    
    for (let i = 0; i < leg; i++) {
      result.push([...result[i], num]);
    }
  }
  
  return result;
};
```

## 나의 수도 코드

1. `result`에 빈 배열(`[]`)을 추가
2. 배열 `nums`가 빌 때까지
    1. `nums`에서 첫 번째 원소를 제거하고 `num`에 저장
    2. `result`의 길이를 `leg`에 저장
    3. `result`의 각 부분 집합을 순회하면서, 각 부분 집합에 `num`을 추가하여 `result`에 추가
3. 최종적으로 `result`를 반환

## 다른 사람의 풀이

```tsx
var subsets = function(nums) {
  const result = [];
  
  const backtrack = (path, index) => {
    result.push([...path]);
    
    for (let i = index; i < nums.length; i++) {
      path.push(nums[i]);
      backtrack(path, i + 1);
      path.pop();
    }
  };
  
  backtrack([], 0);
  
  return result;
};
```

## 다른 사람의 수도 코드

1. **초기화**
    - 결과를 저장할 배열 `result`를 빈 배열로 초기화
    - 백트래킹을 시작하는 함수 `backtrack(path, index)`를 정의
2. **백트래킹 함수 (backtrack)**
    - 현재까지 선택된 원소의 경로 `path`를 결과 `result`에 추가
    - 주어진 배열의 `index`부터 배열 끝까지 반복하며
        - 배열의 현재 원소를 경로 `path`에 추가
        - 재귀적으로 `backtrack(path, index + 1)` 호출해 다음 원소 탐색
        - 호출이 끝나면, 선택을 되돌리기 위해 마지막 원소를 `path`에서 제거
3. **재귀 종료 조건**
    - `index`가 배열의 길이보다 커질 때, 더 이상 선택할 원소가 없으므로 재귀 종료
4. **최종 결과 반환**
    - 모든 재귀 호출이 끝나면 `result`에 저장된 모든 부분 집합을 반환

## 내가 푼 코드와 다른 사람이 푼 코드의 차이점

### **1. 방식의 차이**

- 나의 코드
    - 반복문을 사용해 배열에서 하나씩 원소를 꺼내면서, 기존 부분 집합들에 새로운 원소를 추가해 부분 집합을 확장하는 방식
    - 처음에 `[]`(공집합)에서 시작해서, 배열의 각 원소를 반복적으로 추가하여 기존의 부분 집합을 확장
    - 각 원소가 추가될 때마다 `result` 배열의 길이를 확인하고, 그만큼 새로 추가된 원소가 포함된 부분 집합을 생성
- 다른 사람의 코드
    - 재귀를 통해 각 단계에서 원소를 포함할지 말지를 선택하고, 가능한 모든 선택지를 탐색해 나가는 방식
    - 깊이 우선 탐색(DFS)을 사용하여 부분 집합을 구성하며, 선택된 경로(`path`)를 트리 형태로 탐색함
    - 재귀 호출이 종료되면, 마지막에 선택한 원소를 되돌리면서 다른 선택을 진행함

### 2. **재귀 vs 반복**

- 나의 코드
    - **반복문**을 통해 문제를 해결
    - 각 반복 단계에서 `nums` 배열의 원소를 하나씩 처리하며, 기존 부분 집합들에 새로운 원소를 추가하여 점차 결과를 확장
- 다른 사람의 코드
    - **재귀적** 방식으로 문제를 해결
    - `backtrack` 함수는 재귀적으로 호출되며, 각 재귀 단계에서 현재 원소를 포함하거나 포함하지 않는 두 가지 선택을 진행
    - 깊이 우선 탐색(DFS) 방식으로 모든 경로를 탐색한 후, 선택을 되돌려서 다른 경로도 시도

### 3. **부분 집합 생성 방식**

- 나의 코드
    - 새로운 원소를 기존 부분 집합에 추가하여 확장하는 방식
    - 기존에 저장된 부분 집합들을 기반으로 새로운 원소를 포함한 부분 집합을 추가하는 반복적 확장 방식
- 다른 사람의 코드
    - 모든 원소에 대해 포함/비포함 선택지를 탐색하는 트리 구조의 탐색 방식
    - 각 재귀 호출이 진행되면서 부분 집합이 동적으로 생성되고, 한 번의 재귀 호출이 끝나면 다시 선택을 되돌려 다른 경로도 시도

### 4. **시간 복잡도**

- 나의 코드
    - 시간 복잡도는 O(2^n)
    - 기존에 저장된 부분 집합들을 기반으로 새로운 부분 집합을 추가하는 방식이므로, 역시 2^n개의 부분 집합을 생성함
- **백트래킹**:
    - 시간 복잡도는 O(2^n)
    - 배열의 각 원소에 대해 포함/비포함 두 가지 선택이 있기 때문에 2^n개의 부분 집합을 생성함

**결론적으로, 두 방법 모두 시간 복잡도는 비슷하다.**

### 5. 결론

나의 코드는 반복적 확장 방식으로 반복문을 통해 하나씩 원소를 처리하고 기존의 부분 집합을 확장하는 방법이다.

다른 사람의 코드는 백트래킹 방식으로 재귀를 사용해 선택과 탐색을 깊이 우선으로 진행하여 모든 가능한 조합을 탐색하고 경로를 되돌려 다른 선택을 시도한다.

## 알아둬야 할 것!

### 1. **두 가지 코드 방식의 핵심 요약**

### **1) 나의 코드 (반복 기반 확장 방식)**

- **핵심 아이디어**
    - 주어진 배열에서 하나씩 원소를 꺼내어, 이미 존재하는 모든 부분 집합에 그 원소를 추가해 새로운 부분 집합을 만들어나가는 방식
- **장점**
    - 구현이 직관적이고, 복잡한 재귀를 사용하지 않음
    - 결과 배열을 순차적으로 확장하는 방식이라 쉽게 이해 가능
- **과정**
    1. 시작할 때 `[]`(공집합)을 기본으로 설정
    2. 배열의 각 원소를 순차적으로 꺼내어 기존의 부분 집합에 그 원소를 추가한 새로운 부분 집합을 만듬
    3. 결과 배열에 새로운 부분 집합을 계속해서 추가

### **2) 다른 사람의 코드**

- **핵심 아이디어**
    - 배열의 각 원소에 대해 선택(포함/비포함)을 재귀적으로 결정하며 모든 가능한 부분 집합을 탐색
    - 깊이 우선 탐색(DFS)을 사용해 트리 구조로 모든 경우의 수를 다 탐색하는 방식
- **장점**
    - 재귀적 탐색 방식으로, 상태를 되돌리며 새로운 선택을 탐색하기 때문에 복잡한 문제에도 유연하게 적용 가능
    - 부분 집합 생성과 선택 과정을 트리처럼 시각적으로 이해할 수 있음
- **과정**
    1. 현재 경로(부분 집합)를 결과에 추가
    2. 남은 원소에 대해 선택(포함/비포함)한 후, 재귀적으로 다음 단계로 넘어감
    3. 선택이 끝나면 이전 단계로 돌아가(Backtrack) 다른 경로도 탐색

---

### 2. **두 방법의 비교**

| 비교 항목 | 반복 기반 확장 방식 (당신의 코드) | 백트래킹 방식 |
| --- | --- | --- |
| **방식** | 반복문을 사용해 기존 부분 집합에 새로운 원소를 추가 | 재귀적으로 모든 선택(포함/비포함)을 탐색 |
| **코드의 복잡도** | 간결하고 직관적 | 재귀 호출이 익숙하지 않으면 다소 복잡함 |
| **시간 복잡도** | O(2^n) | O(2^n) |
| **메모리 사용** | 부분 집합을 계속해서 저장해나감 | 재귀 호출 스택 사용 |
| **재귀 사용 여부** | 사용하지 않음 | 재귀를 사용 |
| **장점** | 코드가 직관적이고 간단함 | 트리 구조를 활용한 문제 해결에 적합함 |
| **단점** | 트리 구조를 다루는 문제에는 적합하지 않을 수 있음 | 재귀 호출에 따른 스택 메모리 사용 부담 가능 |

---

### 3. **이 문제를 풀고 알아둬야 할 주요 개념 정리**

1. **부분 집합 문제의 기본 원리**
    - 주어진 배열에서 각 원소를 포함할지 말지를 선택하는 방식으로 부분 집합을 생성한다.
    - 결과적으로 **2^n개의 부분 집합**이 만들어진다.
2. **재귀적 탐색과 백트래킹**
    - 백트래킹은 재귀적으로 선택을 진행하고, 선택을 되돌리며(Backtrack) 다른 선택지를 시도하는 방식이다.
3. **반복 기반 확장 방식**
    - 배열의 원소를 순차적으로 처리하고, 기존의 부분 집합에 새로운 원소를 추가하는 방식이다.
    - **재귀 없이도 직관적인 해결이 가능하다.**
4. **시간 복잡도**
    - 두 방식 모두 시간 복잡도는 O(2^n)이다.
    - 각 원소에 대해 포함 또는 비포함의 두 가지 선택이 있기 때문에, 전체 부분 집합의 수는 2^n개다.
5. **공집합의 포함 여부**
    - 모든 부분 집합에는 반드시 **공집합**이 포함되어야 한다는 점을 잊지 말아야 한다.

---

### 결론

두 가지 방식 모두 문제를 해결하는 유효한 방법이며, 상황에 따라 더 적합한 방식이 있을 수 있다고 생각한다.

재귀적인 문제 해결에 익숙하다면 백트래킹 방식이 유리할 수 있고,

더 직관적인 반복문을 선호한다면 나의 코드 방식이 더 간편하게 느껴질 수 있다고 생각이 된다.

## 회고

이번 문제를 풀면서 얻은 경험은 **조합 문제**, **트리 탐색 문제** 등에도 적용할 수 있을 것이다.

또한, **백트래킹과 반복**이라는 두 가지 접근 방식을 익히면서 더 다양한 문제에 적합한 해결책을 선택할 수 있는 능력을 키웠다.

특히 **백트래킹**은 앞으로 더 복잡한 문제를 해결할 때 매우 유용할 것이라고 생각되며, 이를 다양한 문제에서 응용해보려고 한다.

이번 문제를 통해 **부분 집합**을 구하는 문제 해결 방법을 심도 있게 다뤘고, 이를 통해 여러 가지 개념을 복습할 수 있었다.

두 가지 방식 모두 장단점이 있었지만, 다양한 상황에서 **적절한 방법을 선택**하는 것이 중요하다는 점을 배웠다. 앞으로도 문제를 풀 때 **최적의 방법을 고민**하며 접근할 것이다.
